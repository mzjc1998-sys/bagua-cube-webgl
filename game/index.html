<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
  <title>ç„ç‰¢å¿— - å…«å¦åœ°ç‰¢</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      user-select: none;
      -webkit-tap-highlight-color: transparent;
    }

    body {
      background: #0a0a12;
      overflow: hidden;
      font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
    }

    #gameCanvas {
      display: block;
      margin: 0 auto;
      background: linear-gradient(180deg, #1a1a2e 0%, #0f0f1a 100%);
    }

    /* åŠ è½½ç”»é¢ */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #0a0a12;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 0.5s;
    }

    #loading.hidden {
      opacity: 0;
      pointer-events: none;
    }

    #loading h1 {
      color: #ffd700;
      font-size: 48px;
      margin-bottom: 20px;
      text-shadow: 0 0 20px rgba(255, 215, 0, 0.5);
    }

    #loading p {
      color: #888;
      font-size: 16px;
    }

    .loading-bar {
      width: 200px;
      height: 4px;
      background: #333;
      border-radius: 2px;
      margin-top: 30px;
      overflow: hidden;
    }

    .loading-bar-inner {
      width: 0%;
      height: 100%;
      background: linear-gradient(90deg, #ffd700, #ff6b6b);
      animation: loading 1.5s ease-in-out infinite;
    }

    @keyframes loading {
      0% { width: 0%; }
      50% { width: 100%; }
      100% { width: 0%; }
    }
  </style>
</head>
<body>
  <div id="loading">
    <h1>ç„ç‰¢å¿—</h1>
    <p>å…«å¦åœ°ç‰¢ Â· å‘½è¿è½®å›</p>
    <div class="loading-bar">
      <div class="loading-bar-inner"></div>
    </div>
  </div>

  <canvas id="gameCanvas"></canvas>

  <script>
// ==================== æ¸¸æˆä¸»ç¨‹åº ====================

(function() {
  'use strict';

  // ==================== å¸¸é‡å®šä¹‰ ====================

  const COLORS = {
    // ä¸»é¢˜è‰²
    primary: '#ffd700',
    secondary: '#5ad6ff',
    danger: '#ff4757',
    success: '#2ed573',

    // äº”è¡Œé¢œè‰²
    metal: '#c0c0c0',
    wood: '#2ed573',
    water: '#5ad6ff',
    fire: '#ff6b6b',
    earth: '#d4a574',

    // å¡ç‰Œé¢œè‰²
    attack: '#ff6b6b',
    skill: '#5ad6ff',
    power: '#a855f7',

    // UIé¢œè‰²
    bg: '#1a1a2e',
    bgLight: '#252542',
    bgDark: '#0f0f1a',
    text: '#ffffff',
    textMuted: '#888888',
    border: '#3a3a5a'
  };

  const CARD_WIDTH = 100;
  const CARD_HEIGHT = 140;

  // ==================== æ¸¸æˆçŠ¶æ€ ====================

  const GameState = {
    LOADING: 'loading',
    MAIN_MENU: 'main_menu',
    CHARACTER_SELECT: 'character_select',
    MAP: 'map',
    BATTLE: 'battle',
    REWARD: 'reward',
    GAME_OVER: 'game_over',
    VICTORY: 'victory'
  };

  // ==================== å…¨å±€å˜é‡ ====================

  let canvas, ctx;
  let gameWidth, gameHeight;
  let currentState = GameState.LOADING;
  let animationId;
  let lastTime = 0;
  let deltaTime = 0;

  // è¾“å…¥çŠ¶æ€
  const input = {
    mouseX: 0,
    mouseY: 0,
    isDown: false,
    clicked: false,
    clickX: 0,
    clickY: 0
  };

  // æ¸¸æˆæ•°æ®
  let game = null;

  // åŠ¨ç”»é˜Ÿåˆ—
  let animations = [];

  // é£˜å­—æ•ˆæœ
  let floatingTexts = [];

  // ==================== å¡ç‰Œæ•°æ® ====================

  const CARDS = {
    strike: {
      id: 'strike',
      name: 'æ¨ªåŠˆ',
      type: 'attack',
      cost: 1,
      description: 'é€ æˆ 6 ç‚¹ä¼¤å®³',
      damage: 6
    },
    defend: {
      id: 'defend',
      name: 'æ ¼æŒ¡',
      type: 'skill',
      cost: 1,
      description: 'è·å¾— 5 ç‚¹æŠ¤ç”²',
      armor: 5
    },
    bash: {
      id: 'bash',
      name: 'ç—›å‡»',
      type: 'attack',
      cost: 2,
      description: 'é€ æˆ 8 ç‚¹ä¼¤å®³\næ•Œäººè·å¾— 2 å±‚æ˜“ä¼¤',
      damage: 8,
      vulnerable: 2
    },
    iron_wave: {
      id: 'iron_wave',
      name: 'é“æµª',
      type: 'skill',
      cost: 1,
      description: 'é€ æˆ 5 ç‚¹ä¼¤å®³\nè·å¾— 5 ç‚¹æŠ¤ç”²',
      damage: 5,
      armor: 5
    },
    cleave: {
      id: 'cleave',
      name: 'æ¨ªæ‰«',
      type: 'attack',
      cost: 1,
      description: 'å¯¹æ‰€æœ‰æ•Œäºº\né€ æˆ 8 ç‚¹ä¼¤å®³',
      damage: 8,
      aoe: true
    },
    flex: {
      id: 'flex',
      name: 'è“„åŠ›',
      type: 'skill',
      cost: 0,
      description: 'è·å¾— 2 ç‚¹åŠ›é‡\n(æœ¬å›åˆ)',
      tempStrength: 2
    },
    shrug: {
      id: 'shrug',
      name: 'æŠ¤èº«',
      type: 'skill',
      cost: 1,
      description: 'è·å¾— 8 ç‚¹æŠ¤ç”²',
      armor: 8
    },
    heavy_blade: {
      id: 'heavy_blade',
      name: 'é‡å‰‘',
      type: 'attack',
      cost: 2,
      description: 'é€ æˆ 14 ç‚¹ä¼¤å®³\nåŠ›é‡æ•ˆæœ x3',
      damage: 14,
      strengthMult: 3
    },
    flame_strike: {
      id: 'flame_strike',
      name: 'ç«ç„°æ–©',
      type: 'attack',
      cost: 2,
      description: 'é€ æˆ 12 ç‚¹ç«å±æ€§ä¼¤å®³\næ•Œäººè·å¾— 2 å±‚ç¼çƒ§',
      damage: 12,
      element: 'fire',
      burn: 2
    },
    meditation: {
      id: 'meditation',
      name: 'å†¥æƒ³',
      type: 'skill',
      cost: 0,
      description: 'æŠ½ 1 å¼ ç‰Œ',
      draw: 1
    }
  };

  // ==================== æ•Œäººæ•°æ® ====================

  const ENEMIES = {
    slime: {
      id: 'slime',
      name: 'å²è±å§†',
      hpMin: 12,
      hpMax: 18,
      element: 'water',
      patterns: [
        { type: 'attack', value: 5 },
        { type: 'attack', value: 5 },
        { type: 'defend', value: 4 }
      ]
    },
    skeleton: {
      id: 'skeleton',
      name: 'éª·é«…å…µ',
      hpMin: 25,
      hpMax: 32,
      element: 'earth',
      patterns: [
        { type: 'attack', value: 8 },
        { type: 'attack', value: 8 },
        { type: 'defend', value: 6 }
      ]
    },
    goblin: {
      id: 'goblin',
      name: 'å“¥å¸ƒæ—',
      hpMin: 15,
      hpMax: 22,
      element: 'earth',
      patterns: [
        { type: 'attack', value: 4 },
        { type: 'attack', value: 4 },
        { type: 'buff', value: 2, buffType: 'strength' }
      ]
    },
    fire_imp: {
      id: 'fire_imp',
      name: 'ç«ç„°å°é¬¼',
      hpMin: 20,
      hpMax: 28,
      element: 'fire',
      patterns: [
        { type: 'attack', value: 7 },
        { type: 'debuff', value: 2, debuffType: 'burn' },
        { type: 'attack', value: 7 }
      ]
    },
    stone_golem: {
      id: 'stone_golem',
      name: 'çŸ³å‚€å„¡',
      hpMin: 60,
      hpMax: 80,
      element: 'earth',
      isElite: true,
      patterns: [
        { type: 'attack', value: 12 },
        { type: 'defend', value: 10 },
        { type: 'attack', value: 12 },
        { type: 'buff', value: 2, buffType: 'strength' }
      ]
    }
  };

  // ==================== è§’è‰²æ•°æ® ====================

  const CHARACTERS = {
    swordsman: {
      id: 'swordsman',
      name: 'å‰‘å®¢',
      title: 'é’é”‹å‰‘å£«',
      hp: 80,
      deck: ['strike', 'strike', 'strike', 'strike', 'strike',
             'defend', 'defend', 'defend', 'defend', 'bash']
    },
    taoist: {
      id: 'taoist',
      name: 'é“å£«',
      title: 'å¤ªæçœŸäºº',
      hp: 75,
      deck: ['strike', 'strike', 'strike', 'strike',
             'defend', 'defend', 'defend', 'defend', 'meditation', 'flex'],
      locked: true
    }
  };

  // ==================== å·¥å…·å‡½æ•° ====================

  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  function shuffle(array) {
    const arr = [...array];
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
  }

  function lerp(a, b, t) {
    return a + (b - a) * t;
  }

  function easeOutCubic(t) {
    return 1 - Math.pow(1 - t, 3);
  }

  function easeOutBack(t) {
    const c1 = 1.70158;
    const c3 = c1 + 1;
    return 1 + c3 * Math.pow(t - 1, 3) + c1 * Math.pow(t - 1, 2);
  }

  function pointInRect(px, py, x, y, w, h) {
    return px >= x && px <= x + w && py >= y && py <= y + h;
  }

  // ==================== ç»˜åˆ¶å·¥å…· ====================

  function drawRoundRect(x, y, w, h, r, fill, stroke) {
    ctx.beginPath();
    ctx.roundRect(x, y, w, h, r);
    if (fill) {
      ctx.fillStyle = fill;
      ctx.fill();
    }
    if (stroke) {
      ctx.strokeStyle = stroke;
      ctx.stroke();
    }
  }

  function drawText(text, x, y, options = {}) {
    const {
      size = 16,
      color = COLORS.text,
      align = 'center',
      baseline = 'middle',
      shadow = false
    } = options;

    ctx.font = `${size}px "PingFang SC", "Microsoft YaHei", sans-serif`;
    ctx.textAlign = align;
    ctx.textBaseline = baseline;

    if (shadow) {
      ctx.fillStyle = 'rgba(0,0,0,0.5)';
      ctx.fillText(text, x + 2, y + 2);
    }

    ctx.fillStyle = color;
    ctx.fillText(text, x, y);
  }

  function drawButton(x, y, w, h, text, options = {}) {
    const {
      color = COLORS.primary,
      textColor = '#000',
      disabled = false,
      hovered = false
    } = options;

    const isHover = hovered || pointInRect(input.mouseX, input.mouseY, x, y, w, h);

    // èƒŒæ™¯
    const bgColor = disabled ? '#444' : (isHover ? lightenColor(color, 20) : color);
    drawRoundRect(x, y, w, h, 8, bgColor);

    // è¾¹æ¡†å…‰æ•ˆ
    if (isHover && !disabled) {
      ctx.shadowColor = color;
      ctx.shadowBlur = 10;
      drawRoundRect(x, y, w, h, 8, null, color);
      ctx.shadowBlur = 0;
    }

    // æ–‡å­—
    drawText(text, x + w/2, y + h/2, {
      color: disabled ? '#888' : textColor,
      size: 18
    });

    // æ£€æµ‹ç‚¹å‡»
    if (input.clicked && isHover && !disabled) {
      return true;
    }
    return false;
  }

  function lightenColor(color, percent) {
    const num = parseInt(color.replace('#', ''), 16);
    const amt = Math.round(2.55 * percent);
    const R = (num >> 16) + amt;
    const G = (num >> 8 & 0x00FF) + amt;
    const B = (num & 0x0000FF) + amt;
    return '#' + (0x1000000 +
      (R < 255 ? (R < 1 ? 0 : R) : 255) * 0x10000 +
      (G < 255 ? (G < 1 ? 0 : G) : 255) * 0x100 +
      (B < 255 ? (B < 1 ? 0 : B) : 255)
    ).toString(16).slice(1);
  }

  // ==================== é£˜å­—æ•ˆæœ ====================

  function addFloatingText(text, x, y, color = COLORS.danger) {
    floatingTexts.push({
      text,
      x,
      y,
      color,
      alpha: 1,
      vy: -2,
      life: 60
    });
  }

  function updateFloatingTexts() {
    for (let i = floatingTexts.length - 1; i >= 0; i--) {
      const ft = floatingTexts[i];
      ft.y += ft.vy;
      ft.life--;
      ft.alpha = ft.life / 60;
      if (ft.life <= 0) {
        floatingTexts.splice(i, 1);
      }
    }
  }

  function drawFloatingTexts() {
    for (const ft of floatingTexts) {
      ctx.globalAlpha = ft.alpha;
      drawText(ft.text, ft.x, ft.y, {
        color: ft.color,
        size: 24,
        shadow: true
      });
    }
    ctx.globalAlpha = 1;
  }

  // ==================== æ¸¸æˆç±» ====================

  class Game {
    constructor() {
      this.player = null;
      this.enemies = [];
      this.floor = 1;
      this.gold = 99;
      this.deck = [];
      this.drawPile = [];
      this.hand = [];
      this.discardPile = [];
      this.energy = 3;
      this.maxEnergy = 3;
      this.turn = 0;
      this.isPlayerTurn = true;
      this.selectedCard = null;
      this.selectedCardIndex = -1;
      this.hoveredCard = -1;
      this.targetingMode = false;
      this.battleLog = [];
      this.map = null;
      this.currentNode = null;
    }

    startNewGame(characterId) {
      const char = CHARACTERS[characterId];

      this.player = {
        name: char.name,
        hp: char.hp,
        maxHp: char.hp,
        armor: 0,
        strength: 0,
        dexterity: 0,
        buffs: {}
      };

      this.deck = char.deck.map(id => this.createCard(id));
      this.floor = 1;
      this.gold = 99;

      // ç”Ÿæˆåœ°å›¾
      this.generateMap();

      currentState = GameState.MAP;
    }

    createCard(id) {
      const data = CARDS[id];
      return {
        ...data,
        uuid: Math.random().toString(36).substr(2, 9)
      };
    }

    generateMap() {
      // ç®€å•çš„åœ°å›¾ç”Ÿæˆ
      this.map = {
        nodes: [],
        currentIndex: 0
      };

      // ç”Ÿæˆ 8 ä¸ªèŠ‚ç‚¹
      const types = ['battle', 'battle', 'battle', 'elite', 'rest', 'shop', 'event', 'boss'];
      for (let i = 0; i < 8; i++) {
        this.map.nodes.push({
          index: i,
          type: i === 7 ? 'boss' : types[i],
          cleared: false,
          available: i === 0
        });
      }
    }

    enterNode(index) {
      const node = this.map.nodes[index];
      if (!node.available || node.cleared) return;

      this.currentNode = node;

      switch (node.type) {
        case 'battle':
          this.startBattle(['slime', 'goblin']);
          break;
        case 'elite':
          this.startBattle(['stone_golem']);
          break;
        case 'boss':
          this.startBattle(['skeleton', 'skeleton', 'fire_imp']);
          break;
        case 'rest':
          // æ¢å¤ 30% HP
          const heal = Math.floor(this.player.maxHp * 0.3);
          this.player.hp = Math.min(this.player.maxHp, this.player.hp + heal);
          this.completeNode();
          break;
        case 'shop':
        case 'event':
          // ç®€åŒ–å¤„ç†
          this.gold += 20;
          this.completeNode();
          break;
      }
    }

    completeNode() {
      this.currentNode.cleared = true;

      // è§£é”ä¸‹ä¸€ä¸ªèŠ‚ç‚¹
      const nextIndex = this.currentNode.index + 1;
      if (nextIndex < this.map.nodes.length) {
        this.map.nodes[nextIndex].available = true;
      }

      // æ£€æŸ¥æ˜¯å¦é€šå…³
      if (this.currentNode.type === 'boss') {
        currentState = GameState.VICTORY;
        return;
      }

      currentState = GameState.MAP;
    }

    startBattle(enemyIds) {
      this.enemies = enemyIds.map((id, i) => this.createEnemy(id, i));
      this.turn = 0;
      this.energy = this.maxEnergy;
      this.drawPile = shuffle([...this.deck]);
      this.hand = [];
      this.discardPile = [];
      this.player.armor = 0;
      this.selectedCard = null;
      this.targetingMode = false;

      // æ•Œäººå†³å®šæ„å›¾
      this.enemies.forEach(e => this.decideEnemyIntent(e));

      // å¼€å§‹ç©å®¶å›åˆ
      this.startPlayerTurn();

      currentState = GameState.BATTLE;
    }

    createEnemy(id, index) {
      const data = ENEMIES[id];
      const hp = randomInt(data.hpMin, data.hpMax);
      return {
        ...data,
        index,
        hp,
        maxHp: hp,
        armor: 0,
        strength: 0,
        buffs: {},
        patternIndex: 0,
        intent: null,
        x: gameWidth * 0.5 + index * 150 - (1) * 75,
        y: gameHeight * 0.3,
        shake: 0
      };
    }

    decideEnemyIntent(enemy) {
      const pattern = enemy.patterns[enemy.patternIndex];
      enemy.intent = { ...pattern };
      enemy.patternIndex = (enemy.patternIndex + 1) % enemy.patterns.length;
    }

    startPlayerTurn() {
      this.turn++;
      this.isPlayerTurn = true;
      this.energy = this.maxEnergy;

      // æŠ½ 5 å¼ ç‰Œ
      this.drawCards(5);

      // æ¸…é™¤ä¸´æ—¶åŠ›é‡
      if (this.player.buffs.tempStrength) {
        this.player.strength -= this.player.buffs.tempStrength;
        delete this.player.buffs.tempStrength;
      }
    }

    endPlayerTurn() {
      if (!this.isPlayerTurn) return;

      this.isPlayerTurn = false;
      this.selectedCard = null;
      this.targetingMode = false;

      // å¼ƒæ‰æ‰‹ç‰Œ
      while (this.hand.length > 0) {
        this.discardPile.push(this.hand.pop());
      }

      // æ•Œäººå›åˆ
      this.executeEnemyTurns();
    }

    async executeEnemyTurns() {
      for (const enemy of this.enemies) {
        if (enemy.hp <= 0) continue;

        await this.delay(500);
        this.executeEnemyAction(enemy);

        if (this.player.hp <= 0) {
          currentState = GameState.GAME_OVER;
          return;
        }
      }

      // å‡å°‘æ•ŒäººæŠ¤ç”²
      this.enemies.forEach(e => e.armor = 0);

      // æ•Œäººå†³å®šä¸‹ä¸€è½®æ„å›¾
      this.enemies.forEach(e => {
        if (e.hp > 0) this.decideEnemyIntent(e);
      });

      // å‡å°‘ç©å®¶æŠ¤ç”²
      this.player.armor = 0;

      // å¼€å§‹æ–°çš„ç©å®¶å›åˆ
      this.startPlayerTurn();
    }

    executeEnemyAction(enemy) {
      const intent = enemy.intent;

      switch (intent.type) {
        case 'attack':
          let damage = intent.value + enemy.strength;

          // æ˜“ä¼¤å¢åŠ ä¼¤å®³
          if (this.player.buffs.vulnerable > 0) {
            damage = Math.floor(damage * 1.5);
          }

          // æŠ¤ç”²å‡ä¼¤
          if (this.player.armor >= damage) {
            this.player.armor -= damage;
            addFloatingText(`-${damage} æŠ¤ç”²`, gameWidth * 0.25, gameHeight * 0.5, COLORS.secondary);
          } else {
            const remainDamage = damage - this.player.armor;
            this.player.armor = 0;
            this.player.hp -= remainDamage;
            addFloatingText(`-${remainDamage}`, gameWidth * 0.25, gameHeight * 0.5, COLORS.danger);
          }
          break;

        case 'defend':
          enemy.armor += intent.value;
          addFloatingText(`+${intent.value} æŠ¤ç”²`, enemy.x, enemy.y, COLORS.secondary);
          break;

        case 'buff':
          if (intent.buffType === 'strength') {
            enemy.strength += intent.value;
            addFloatingText(`+${intent.value} åŠ›é‡`, enemy.x, enemy.y, COLORS.primary);
          }
          break;

        case 'debuff':
          if (intent.debuffType === 'burn') {
            this.player.buffs.burn = (this.player.buffs.burn || 0) + intent.value;
            addFloatingText(`+${intent.value} ç¼çƒ§`, gameWidth * 0.25, gameHeight * 0.5, COLORS.fire);
          }
          break;
      }
    }

    drawCards(count) {
      for (let i = 0; i < count; i++) {
        if (this.hand.length >= 10) break;

        if (this.drawPile.length === 0) {
          if (this.discardPile.length === 0) break;
          this.drawPile = shuffle(this.discardPile);
          this.discardPile = [];
        }

        this.hand.push(this.drawPile.pop());
      }
    }

    playCard(cardIndex, targetIndex = -1) {
      if (!this.isPlayerTurn) return false;

      const card = this.hand[cardIndex];
      if (!card) return false;

      if (this.energy < card.cost) return false;

      // éœ€è¦ç›®æ ‡çš„æ”»å‡»ç‰Œ
      if (card.type === 'attack' && !card.aoe && targetIndex === -1) {
        this.selectedCard = card;
        this.selectedCardIndex = cardIndex;
        this.targetingMode = true;
        return false;
      }

      this.energy -= card.cost;
      this.hand.splice(cardIndex, 1);
      this.discardPile.push(card);

      // æ‰§è¡Œå¡ç‰Œæ•ˆæœ
      this.executeCard(card, targetIndex);

      this.selectedCard = null;
      this.targetingMode = false;

      // æ£€æŸ¥æˆ˜æ–—ç»“æŸ
      this.checkBattleEnd();

      return true;
    }

    executeCard(card, targetIndex) {
      const player = this.player;

      // ä¼¤å®³
      if (card.damage) {
        let damage = card.damage + player.strength * (card.strengthMult || 1);

        if (card.aoe) {
          // AOE ä¼¤å®³
          this.enemies.forEach(enemy => {
            if (enemy.hp > 0) {
              this.dealDamageToEnemy(enemy, damage);
            }
          });
        } else {
          // å•ä½“ä¼¤å®³
          const enemy = this.enemies[targetIndex];
          if (enemy && enemy.hp > 0) {
            this.dealDamageToEnemy(enemy, damage);
          }
        }
      }

      // æŠ¤ç”²
      if (card.armor) {
        let armor = card.armor + player.dexterity;
        player.armor += armor;
        addFloatingText(`+${armor} æŠ¤ç”²`, gameWidth * 0.25, gameHeight * 0.6, COLORS.secondary);
      }

      // æ˜“ä¼¤
      if (card.vulnerable) {
        const enemy = this.enemies[targetIndex];
        if (enemy) {
          enemy.buffs.vulnerable = (enemy.buffs.vulnerable || 0) + card.vulnerable;
        }
      }

      // ç¼çƒ§
      if (card.burn) {
        const enemy = this.enemies[targetIndex];
        if (enemy) {
          enemy.buffs.burn = (enemy.buffs.burn || 0) + card.burn;
        }
      }

      // ä¸´æ—¶åŠ›é‡
      if (card.tempStrength) {
        player.strength += card.tempStrength;
        player.buffs.tempStrength = (player.buffs.tempStrength || 0) + card.tempStrength;
        addFloatingText(`+${card.tempStrength} åŠ›é‡`, gameWidth * 0.25, gameHeight * 0.5, COLORS.primary);
      }

      // æŠ½ç‰Œ
      if (card.draw) {
        this.drawCards(card.draw);
      }
    }

    dealDamageToEnemy(enemy, baseDamage) {
      let damage = baseDamage;

      // æ˜“ä¼¤
      if (enemy.buffs.vulnerable > 0) {
        damage = Math.floor(damage * 1.5);
      }

      // æŠ¤ç”²å‡ä¼¤
      if (enemy.armor >= damage) {
        enemy.armor -= damage;
        addFloatingText(`-${damage}`, enemy.x, enemy.y, COLORS.secondary);
      } else {
        const remainDamage = damage - enemy.armor;
        enemy.armor = 0;
        enemy.hp -= remainDamage;
        enemy.shake = 10;
        addFloatingText(`-${remainDamage}`, enemy.x, enemy.y, COLORS.danger);
      }
    }

    checkBattleEnd() {
      // æ£€æŸ¥æ‰€æœ‰æ•Œäººæ­»äº¡
      const allDead = this.enemies.every(e => e.hp <= 0);
      if (allDead) {
        // èƒœåˆ©
        setTimeout(() => {
          currentState = GameState.REWARD;
        }, 500);
      }
    }

    collectReward() {
      this.gold += 20;
      this.completeNode();
    }

    delay(ms) {
      return new Promise(resolve => setTimeout(resolve, ms));
    }
  }

  // ==================== æ¸²æŸ“å‡½æ•° ====================

  function render() {
    // æ¸…å±
    ctx.fillStyle = COLORS.bgDark;
    ctx.fillRect(0, 0, gameWidth, gameHeight);

    switch (currentState) {
      case GameState.MAIN_MENU:
        renderMainMenu();
        break;
      case GameState.CHARACTER_SELECT:
        renderCharacterSelect();
        break;
      case GameState.MAP:
        renderMap();
        break;
      case GameState.BATTLE:
        renderBattle();
        break;
      case GameState.REWARD:
        renderReward();
        break;
      case GameState.GAME_OVER:
        renderGameOver();
        break;
      case GameState.VICTORY:
        renderVictory();
        break;
    }

    // é£˜å­—
    drawFloatingTexts();
  }

  function renderMainMenu() {
    // èƒŒæ™¯
    const gradient = ctx.createLinearGradient(0, 0, 0, gameHeight);
    gradient.addColorStop(0, '#1a1a2e');
    gradient.addColorStop(1, '#0f0f1a');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, gameWidth, gameHeight);

    // å…«å¦å›¾æ¡ˆèƒŒæ™¯
    ctx.save();
    ctx.globalAlpha = 0.1;
    ctx.translate(gameWidth/2, gameHeight/2 - 50);
    ctx.rotate(Date.now() / 5000);
    drawBaguaSymbol(0, 0, 150);
    ctx.restore();

    // æ ‡é¢˜
    drawText('ç„ç‰¢å¿—', gameWidth/2, gameHeight * 0.25, {
      size: 64,
      color: COLORS.primary,
      shadow: true
    });

    drawText('å…«å¦åœ°ç‰¢ Â· å‘½è¿è½®å›', gameWidth/2, gameHeight * 0.35, {
      size: 20,
      color: COLORS.textMuted
    });

    // æŒ‰é’®
    const btnW = 200;
    const btnH = 50;
    const btnX = (gameWidth - btnW) / 2;

    if (drawButton(btnX, gameHeight * 0.55, btnW, btnH, 'å¼€å§‹æ¸¸æˆ')) {
      currentState = GameState.CHARACTER_SELECT;
    }

    if (drawButton(btnX, gameHeight * 0.65, btnW, btnH, 'ç»§ç»­æ¸¸æˆ', { disabled: true })) {
      // ç»§ç»­æ¸¸æˆ
    }

    // ç‰ˆæœ¬ä¿¡æ¯
    drawText('v0.1.0 å¼€å‘ç‰ˆ', gameWidth/2, gameHeight - 30, {
      size: 12,
      color: COLORS.textMuted
    });
  }

  function drawBaguaSymbol(x, y, r) {
    ctx.beginPath();
    ctx.arc(x, y, r, 0, Math.PI * 2);
    ctx.strokeStyle = COLORS.primary;
    ctx.lineWidth = 2;
    ctx.stroke();

    // ç®€åŒ–çš„å…«å¦å›¾æ¡ˆ
    for (let i = 0; i < 8; i++) {
      const angle = (i / 8) * Math.PI * 2 - Math.PI / 2;
      const x1 = x + Math.cos(angle) * (r * 0.6);
      const y1 = y + Math.sin(angle) * (r * 0.6);
      const x2 = x + Math.cos(angle) * r;
      const y2 = y + Math.sin(angle) * r;

      ctx.beginPath();
      ctx.moveTo(x1, y1);
      ctx.lineTo(x2, y2);
      ctx.stroke();
    }
  }

  function renderCharacterSelect() {
    // èƒŒæ™¯
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, gameWidth, gameHeight);

    // æ ‡é¢˜
    drawText('é€‰æ‹©è§’è‰²', gameWidth/2, 60, {
      size: 32,
      color: COLORS.primary
    });

    // è§’è‰²å¡ç‰‡
    const chars = Object.values(CHARACTERS);
    const cardW = 180;
    const cardH = 280;
    const gap = 30;
    const startX = (gameWidth - (chars.length * cardW + (chars.length - 1) * gap)) / 2;

    chars.forEach((char, i) => {
      const x = startX + i * (cardW + gap);
      const y = 120;
      const isHover = pointInRect(input.mouseX, input.mouseY, x, y, cardW, cardH);

      // å¡ç‰‡èƒŒæ™¯
      drawRoundRect(x, y, cardW, cardH, 12,
        char.locked ? '#333' : (isHover ? '#3a3a5a' : COLORS.bgLight),
        isHover && !char.locked ? COLORS.primary : COLORS.border
      );

      // è§’è‰²å›¾æ ‡ï¼ˆç®€åŒ–ï¼‰
      ctx.fillStyle = char.locked ? '#555' : COLORS.primary;
      ctx.beginPath();
      ctx.arc(x + cardW/2, y + 80, 40, 0, Math.PI * 2);
      ctx.fill();

      // è§’è‰²åç§°
      drawText(char.name, x + cardW/2, y + 150, {
        size: 24,
        color: char.locked ? '#666' : COLORS.text
      });

      // è§’è‰²ç§°å·
      drawText(char.title, x + cardW/2, y + 180, {
        size: 14,
        color: char.locked ? '#555' : COLORS.textMuted
      });

      // HP
      drawText(`ç”Ÿå‘½: ${char.hp}`, x + cardW/2, y + 220, {
        size: 14,
        color: char.locked ? '#555' : COLORS.danger
      });

      // é”å®šæ ‡å¿—
      if (char.locked) {
        drawText('ğŸ”’ æœªè§£é”', x + cardW/2, y + 250, {
          size: 14,
          color: '#666'
        });
      }

      // ç‚¹å‡»é€‰æ‹©
      if (input.clicked && isHover && !char.locked) {
        game = new Game();
        game.startNewGame(char.id);
      }
    });

    // è¿”å›æŒ‰é’®
    if (drawButton(20, 20, 80, 40, 'è¿”å›', { color: COLORS.bgLight, textColor: COLORS.text })) {
      currentState = GameState.MAIN_MENU;
    }
  }

  function renderMap() {
    // èƒŒæ™¯
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, gameWidth, gameHeight);

    // æ ‡é¢˜
    drawText(`ç¬¬ ${game.floor} å±‚ - åœŸç‰¢`, gameWidth/2, 40, {
      size: 24,
      color: COLORS.primary
    });

    // ç©å®¶ä¿¡æ¯
    drawText(`${game.player.name}`, 80, 80, { size: 16 });
    drawText(`HP: ${game.player.hp}/${game.player.maxHp}`, 80, 105, {
      size: 14,
      color: COLORS.danger
    });
    drawText(`é‡‘å¸: ${game.gold}`, 80, 125, {
      size: 14,
      color: COLORS.primary
    });

    // åœ°å›¾èŠ‚ç‚¹
    const nodeR = 35;
    const startY = 180;
    const gapY = 60;

    game.map.nodes.forEach((node, i) => {
      const x = gameWidth / 2;
      const y = startY + i * gapY;

      const isHover = Math.hypot(input.mouseX - x, input.mouseY - y) < nodeR;

      // è¿æ¥çº¿
      if (i < game.map.nodes.length - 1) {
        ctx.beginPath();
        ctx.moveTo(x, y + nodeR);
        ctx.lineTo(x, y + gapY - nodeR);
        ctx.strokeStyle = node.cleared ? COLORS.success : COLORS.border;
        ctx.lineWidth = 2;
        ctx.stroke();
      }

      // èŠ‚ç‚¹åœ†åœˆ
      ctx.beginPath();
      ctx.arc(x, y, nodeR, 0, Math.PI * 2);

      let nodeColor = COLORS.bgLight;
      if (node.cleared) {
        nodeColor = COLORS.success;
      } else if (node.available) {
        nodeColor = isHover ? COLORS.primary : COLORS.bgLight;
      } else {
        nodeColor = '#333';
      }

      ctx.fillStyle = nodeColor;
      ctx.fill();
      ctx.strokeStyle = node.available && !node.cleared ? COLORS.primary : COLORS.border;
      ctx.lineWidth = 2;
      ctx.stroke();

      // èŠ‚ç‚¹å›¾æ ‡
      let icon = '?';
      let iconColor = COLORS.text;
      switch (node.type) {
        case 'battle': icon = 'âš”'; break;
        case 'elite': icon = 'ğŸ’€'; iconColor = COLORS.primary; break;
        case 'boss': icon = 'ğŸ‘¹'; iconColor = COLORS.danger; break;
        case 'rest': icon = 'ğŸ”¥'; break;
        case 'shop': icon = 'ğŸª'; break;
        case 'event': icon = 'â“'; break;
      }

      if (node.cleared) {
        icon = 'âœ“';
        iconColor = '#fff';
      }

      drawText(icon, x, y, { size: 24, color: iconColor });

      // ç‚¹å‡»è¿›å…¥
      if (input.clicked && isHover && node.available && !node.cleared) {
        game.enterNode(i);
      }
    });
  }

  function renderBattle() {
    // èƒŒæ™¯
    const gradient = ctx.createLinearGradient(0, 0, 0, gameHeight);
    gradient.addColorStop(0, '#1a1a2e');
    gradient.addColorStop(0.5, '#252542');
    gradient.addColorStop(1, '#1a1a2e');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, gameWidth, gameHeight);

    // æˆ˜æ–—åœºæ™¯åˆ†éš”çº¿
    ctx.beginPath();
    ctx.moveTo(0, gameHeight * 0.55);
    ctx.lineTo(gameWidth, gameHeight * 0.55);
    ctx.strokeStyle = COLORS.border;
    ctx.lineWidth = 1;
    ctx.stroke();

    // æ•ŒäººåŒºåŸŸ
    renderEnemies();

    // ç©å®¶åŒºåŸŸ
    renderPlayer();

    // æ‰‹ç‰ŒåŒºåŸŸ
    renderHand();

    // UI
    renderBattleUI();

    // ç›®æ ‡é€‰æ‹©æŒ‡ç¤º
    if (game.targetingMode) {
      drawText('é€‰æ‹©ç›®æ ‡', gameWidth/2, gameHeight * 0.45, {
        size: 20,
        color: COLORS.primary
      });
    }
  }

  function renderEnemies() {
    const baseX = gameWidth / 2;
    const baseY = gameHeight * 0.25;
    const spacing = 160;

    game.enemies.forEach((enemy, i) => {
      if (enemy.hp <= 0) return;

      // è®¡ç®—ä½ç½®
      const offset = (game.enemies.filter(e => e.hp > 0).length - 1) / 2;
      const aliveIndex = game.enemies.filter((e, j) => e.hp > 0 && j < i).length;
      const x = baseX + (aliveIndex - offset) * spacing;
      const y = baseY;

      enemy.x = x;
      enemy.y = y;

      // éœ‡åŠ¨æ•ˆæœ
      let shakeX = 0;
      if (enemy.shake > 0) {
        shakeX = (Math.random() - 0.5) * enemy.shake;
        enemy.shake -= 0.5;
      }

      const isHover = Math.hypot(input.mouseX - x, input.mouseY - y) < 50;
      const isTargetable = game.targetingMode && isHover;

      // æ•Œäººåœ†å½¢ï¼ˆç®€åŒ–ï¼‰
      ctx.beginPath();
      ctx.arc(x + shakeX, y, 45, 0, Math.PI * 2);
      ctx.fillStyle = isTargetable ? '#4a4a6a' : COLORS.bgLight;
      ctx.fill();
      ctx.strokeStyle = isTargetable ? COLORS.danger : COLORS.border;
      ctx.lineWidth = isTargetable ? 3 : 2;
      ctx.stroke();

      // æ•Œäººåç§°
      drawText(enemy.name, x, y - 70, { size: 14, color: COLORS.text });

      // HP æ¡
      const hpBarW = 70;
      const hpBarH = 8;
      const hpBarX = x - hpBarW/2;
      const hpBarY = y + 55;

      drawRoundRect(hpBarX, hpBarY, hpBarW, hpBarH, 4, '#333');
      const hpPercent = enemy.hp / enemy.maxHp;
      drawRoundRect(hpBarX, hpBarY, hpBarW * hpPercent, hpBarH, 4, COLORS.danger);

      drawText(`${enemy.hp}/${enemy.maxHp}`, x, hpBarY + 20, {
        size: 12,
        color: COLORS.text
      });

      // æŠ¤ç”²
      if (enemy.armor > 0) {
        drawText(`ğŸ›¡${enemy.armor}`, x - 40, y, { size: 14, color: COLORS.secondary });
      }

      // æ„å›¾
      if (enemy.intent) {
        let intentText = '';
        let intentColor = COLORS.text;

        switch (enemy.intent.type) {
          case 'attack':
            const dmg = enemy.intent.value + enemy.strength;
            intentText = `âš” ${dmg}`;
            intentColor = COLORS.danger;
            break;
          case 'defend':
            intentText = `ğŸ›¡ ${enemy.intent.value}`;
            intentColor = COLORS.secondary;
            break;
          case 'buff':
            intentText = 'â†‘';
            intentColor = COLORS.primary;
            break;
          case 'debuff':
            intentText = 'â˜ ';
            intentColor = COLORS.fire;
            break;
        }

        drawText(intentText, x, y - 55, { size: 18, color: intentColor });
      }

      // Buff/Debuff å›¾æ ‡
      let buffY = y + 75;
      if (enemy.buffs.vulnerable > 0) {
        drawText(`ğŸ’”${enemy.buffs.vulnerable}`, x - 15, buffY, { size: 12 });
      }
      if (enemy.buffs.burn > 0) {
        drawText(`ğŸ”¥${enemy.buffs.burn}`, x + 15, buffY, { size: 12 });
      }

      // ç‚¹å‡»é€‰æ‹©ç›®æ ‡
      if (input.clicked && isTargetable) {
        game.playCard(game.selectedCardIndex, i);
      }
    });
  }

  function renderPlayer() {
    const x = gameWidth * 0.15;
    const y = gameHeight * 0.45;

    // ç©å®¶åœ†å½¢
    ctx.beginPath();
    ctx.arc(x, y, 50, 0, Math.PI * 2);
    ctx.fillStyle = COLORS.bgLight;
    ctx.fill();
    ctx.strokeStyle = COLORS.primary;
    ctx.lineWidth = 3;
    ctx.stroke();

    // åç§°
    drawText(game.player.name, x, y - 75, { size: 16, color: COLORS.text });

    // HP æ¡
    const hpBarW = 100;
    const hpBarH = 12;
    const hpBarX = x - hpBarW/2;
    const hpBarY = y + 60;

    drawRoundRect(hpBarX, hpBarY, hpBarW, hpBarH, 6, '#333');
    const hpPercent = game.player.hp / game.player.maxHp;
    const hpColor = hpPercent > 0.5 ? COLORS.danger : (hpPercent > 0.25 ? '#ff9f43' : '#ff4757');
    drawRoundRect(hpBarX, hpBarY, hpBarW * hpPercent, hpBarH, 6, hpColor);

    drawText(`${game.player.hp}/${game.player.maxHp}`, x, hpBarY + 25, {
      size: 14,
      color: COLORS.text
    });

    // æŠ¤ç”²
    if (game.player.armor > 0) {
      ctx.beginPath();
      ctx.arc(x + 55, y - 20, 20, 0, Math.PI * 2);
      ctx.fillStyle = COLORS.secondary;
      ctx.fill();
      drawText(game.player.armor.toString(), x + 55, y - 20, {
        size: 14,
        color: '#000'
      });
    }

    // åŠ›é‡
    if (game.player.strength > 0) {
      drawText(`âš”+${game.player.strength}`, x + 55, y + 15, {
        size: 12,
        color: COLORS.danger
      });
    }
  }

  function renderHand() {
    const handY = gameHeight - 100;
    const cardW = CARD_WIDTH;
    const cardH = CARD_HEIGHT;

    const handCount = game.hand.length;
    const maxSpread = Math.min(cardW * 0.7, (gameWidth - 200) / Math.max(handCount, 1));
    const totalWidth = (handCount - 1) * maxSpread + cardW;
    const startX = (gameWidth - totalWidth) / 2;

    // æ£€æµ‹æ‚¬åœ
    let newHovered = -1;

    game.hand.forEach((card, i) => {
      const x = startX + i * maxSpread;
      const y = handY;

      if (pointInRect(input.mouseX, input.mouseY, x, y - 20, cardW, cardH + 20)) {
        newHovered = i;
      }
    });

    game.hoveredCard = newHovered;

    // ç»˜åˆ¶å¡ç‰Œ
    game.hand.forEach((card, i) => {
      const x = startX + i * maxSpread;
      let y = handY;

      const isHovered = i === game.hoveredCard;
      const isSelected = i === game.selectedCardIndex;
      const canPlay = game.isPlayerTurn && game.energy >= card.cost;

      if (isHovered) {
        y -= 30;
      }

      // å¡ç‰ŒèƒŒæ™¯
      let bgColor = COLORS.bgLight;
      let borderColor = COLORS.border;

      if (card.type === 'attack') borderColor = COLORS.attack;
      else if (card.type === 'skill') borderColor = COLORS.skill;
      else if (card.type === 'power') borderColor = COLORS.power;

      if (isSelected) {
        borderColor = COLORS.primary;
      }

      if (!canPlay) {
        ctx.globalAlpha = 0.6;
      }

      drawRoundRect(x, y, cardW, cardH, 8, bgColor, borderColor);

      // å¡ç‰Œå†…å®¹
      // è´¹ç”¨
      ctx.beginPath();
      ctx.arc(x + 18, y + 18, 14, 0, Math.PI * 2);
      ctx.fillStyle = canPlay ? COLORS.primary : '#666';
      ctx.fill();
      drawText(card.cost.toString(), x + 18, y + 18, {
        size: 16,
        color: '#000'
      });

      // åç§°
      drawText(card.name, x + cardW/2, y + 45, {
        size: 14,
        color: COLORS.text
      });

      // ç±»å‹æ¡
      const typeColor = card.type === 'attack' ? COLORS.attack :
                       card.type === 'skill' ? COLORS.skill : COLORS.power;
      drawRoundRect(x + 10, y + 60, cardW - 20, 3, 1, typeColor);

      // æè¿°
      const lines = card.description.split('\n');
      lines.forEach((line, li) => {
        drawText(line, x + cardW/2, y + 85 + li * 16, {
          size: 11,
          color: COLORS.textMuted
        });
      });

      ctx.globalAlpha = 1;

      // ç‚¹å‡»æ‰“å‡º
      if (input.clicked && isHovered && canPlay && !game.targetingMode) {
        game.playCard(i);
      }
    });
  }

  function renderBattleUI() {
    // èƒ½é‡
    const energyX = 60;
    const energyY = gameHeight - 160;

    ctx.beginPath();
    ctx.arc(energyX, energyY, 30, 0, Math.PI * 2);
    ctx.fillStyle = COLORS.bgLight;
    ctx.fill();
    ctx.strokeStyle = COLORS.primary;
    ctx.lineWidth = 3;
    ctx.stroke();

    drawText(`${game.energy}/${game.maxEnergy}`, energyX, energyY, {
      size: 20,
      color: COLORS.primary
    });

    // æŠ½ç‰Œå †
    drawText(`æŠ½ç‰Œå †`, gameWidth - 70, gameHeight - 180, {
      size: 12,
      color: COLORS.textMuted
    });
    drawText(game.drawPile.length.toString(), gameWidth - 70, gameHeight - 155, {
      size: 20,
      color: COLORS.text
    });

    // å¼ƒç‰Œå †
    drawText(`å¼ƒç‰Œå †`, gameWidth - 70, gameHeight - 120, {
      size: 12,
      color: COLORS.textMuted
    });
    drawText(game.discardPile.length.toString(), gameWidth - 70, gameHeight - 95, {
      size: 20,
      color: COLORS.text
    });

    // ç»“æŸå›åˆæŒ‰é’®
    if (game.isPlayerTurn) {
      if (drawButton(gameWidth - 130, gameHeight - 60, 110, 40, 'ç»“æŸå›åˆ', {
        color: game.targetingMode ? '#666' : COLORS.danger,
        textColor: '#fff'
      })) {
        if (!game.targetingMode) {
          game.endPlayerTurn();
        }
      }
    } else {
      drawText('æ•Œæ–¹å›åˆ...', gameWidth - 75, gameHeight - 40, {
        size: 14,
        color: COLORS.textMuted
      });
    }

    // å–æ¶ˆç›®æ ‡é€‰æ‹©
    if (game.targetingMode) {
      if (drawButton(gameWidth/2 - 50, gameHeight * 0.5, 100, 35, 'å–æ¶ˆ', {
        color: COLORS.bgLight,
        textColor: COLORS.text
      })) {
        game.targetingMode = false;
        game.selectedCard = null;
        game.selectedCardIndex = -1;
      }
    }

    // å›åˆæ•°
    drawText(`å›åˆ ${game.turn}`, 60, 30, { size: 14, color: COLORS.textMuted });
  }

  function renderReward() {
    // èƒŒæ™¯
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, gameWidth, gameHeight);

    drawText('æˆ˜æ–—èƒœåˆ©!', gameWidth/2, gameHeight * 0.3, {
      size: 36,
      color: COLORS.primary
    });

    drawText('è·å¾—å¥–åŠ±:', gameWidth/2, gameHeight * 0.45, {
      size: 20,
      color: COLORS.text
    });

    drawText('ğŸ’° 20 é‡‘å¸', gameWidth/2, gameHeight * 0.55, {
      size: 24,
      color: COLORS.primary
    });

    if (drawButton(gameWidth/2 - 75, gameHeight * 0.7, 150, 50, 'ç»§ç»­')) {
      game.collectReward();
    }
  }

  function renderGameOver() {
    ctx.fillStyle = 'rgba(0,0,0,0.8)';
    ctx.fillRect(0, 0, gameWidth, gameHeight);

    drawText('æ¸¸æˆç»“æŸ', gameWidth/2, gameHeight * 0.35, {
      size: 48,
      color: COLORS.danger
    });

    drawText(`åˆ°è¾¾ç¬¬ ${game.floor} å±‚`, gameWidth/2, gameHeight * 0.5, {
      size: 20,
      color: COLORS.textMuted
    });

    if (drawButton(gameWidth/2 - 75, gameHeight * 0.65, 150, 50, 'è¿”å›ä¸»èœå•')) {
      currentState = GameState.MAIN_MENU;
      game = null;
    }
  }

  function renderVictory() {
    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, gameWidth, gameHeight);

    drawText('é€šå…³æˆåŠŸ!', gameWidth/2, gameHeight * 0.3, {
      size: 48,
      color: COLORS.primary
    });

    drawText('æ­å–œä½ å¾æœäº†åœŸç‰¢!', gameWidth/2, gameHeight * 0.45, {
      size: 20,
      color: COLORS.text
    });

    drawText(`è·å¾—é‡‘å¸: ${game.gold}`, gameWidth/2, gameHeight * 0.55, {
      size: 18,
      color: COLORS.primary
    });

    if (drawButton(gameWidth/2 - 75, gameHeight * 0.7, 150, 50, 'è¿”å›ä¸»èœå•')) {
      currentState = GameState.MAIN_MENU;
      game = null;
    }
  }

  // ==================== æ¸¸æˆå¾ªç¯ ====================

  function gameLoop(timestamp) {
    deltaTime = timestamp - lastTime;
    lastTime = timestamp;

    // æ›´æ–°
    updateFloatingTexts();

    // æ¸²æŸ“
    render();

    // é‡ç½®è¾“å…¥
    input.clicked = false;

    animationId = requestAnimationFrame(gameLoop);
  }

  // ==================== åˆå§‹åŒ– ====================

  function init() {
    canvas = document.getElementById('gameCanvas');
    ctx = canvas.getContext('2d');

    // è®¾ç½®ç”»å¸ƒå¤§å°
    resize();
    window.addEventListener('resize', resize);

    // è¾“å…¥äº‹ä»¶
    canvas.addEventListener('mousemove', handleMouseMove);
    canvas.addEventListener('mousedown', handleMouseDown);
    canvas.addEventListener('mouseup', handleMouseUp);
    canvas.addEventListener('touchstart', handleTouchStart, { passive: false });
    canvas.addEventListener('touchmove', handleTouchMove, { passive: false });
    canvas.addEventListener('touchend', handleTouchEnd, { passive: false });

    // éšè—åŠ è½½ç”»é¢
    setTimeout(() => {
      document.getElementById('loading').classList.add('hidden');
      currentState = GameState.MAIN_MENU;
    }, 1000);

    // å¼€å§‹æ¸¸æˆå¾ªç¯
    animationId = requestAnimationFrame(gameLoop);
  }

  function resize() {
    const dpr = window.devicePixelRatio || 1;

    // ä¿æŒ 16:9 æˆ–è‡ªé€‚åº”
    const maxWidth = window.innerWidth;
    const maxHeight = window.innerHeight;

    gameWidth = Math.min(maxWidth, 800);
    gameHeight = Math.min(maxHeight, 600);

    // ä¿æŒå®½é«˜æ¯”
    if (gameWidth / gameHeight > maxWidth / maxHeight) {
      gameWidth = maxHeight * (800 / 600);
    } else {
      gameHeight = gameWidth * (600 / 800);
    }

    gameWidth = Math.floor(gameWidth);
    gameHeight = Math.floor(gameHeight);

    canvas.width = gameWidth * dpr;
    canvas.height = gameHeight * dpr;
    canvas.style.width = gameWidth + 'px';
    canvas.style.height = gameHeight + 'px';

    ctx.scale(dpr, dpr);
  }

  function handleMouseMove(e) {
    const rect = canvas.getBoundingClientRect();
    input.mouseX = e.clientX - rect.left;
    input.mouseY = e.clientY - rect.top;
  }

  function handleMouseDown(e) {
    input.isDown = true;
    input.clickX = input.mouseX;
    input.clickY = input.mouseY;
  }

  function handleMouseUp(e) {
    input.isDown = false;
    input.clicked = true;
  }

  function handleTouchStart(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    input.mouseX = touch.clientX - rect.left;
    input.mouseY = touch.clientY - rect.top;
    input.isDown = true;
  }

  function handleTouchMove(e) {
    e.preventDefault();
    const touch = e.touches[0];
    const rect = canvas.getBoundingClientRect();
    input.mouseX = touch.clientX - rect.left;
    input.mouseY = touch.clientY - rect.top;
  }

  function handleTouchEnd(e) {
    e.preventDefault();
    input.isDown = false;
    input.clicked = true;
  }

  // å¯åŠ¨
  window.addEventListener('DOMContentLoaded', init);

})();
  </script>
</body>
</html>
