# æŠ€æœ¯æ¶æ„æ–‡æ¡£

## ğŸ—ï¸ æ•´ä½“æ¶æ„

### æ¶æ„å›¾

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         å¾®ä¿¡å°æ¸¸æˆè¿è¡Œæ—¶                             â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                      æ¸¸æˆå¼•æ“å±‚ (Cocos Creator)              â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚                                                              â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚                   æ ¸å¿ƒæ¸¸æˆç³»ç»Ÿ                         â”‚   â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚   â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â”‚ Battle  â”‚ â”‚  Card   â”‚ â”‚ Dungeon â”‚ â”‚ Entity  â”‚    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â”‚ System  â”‚ â”‚ System  â”‚ â”‚Generatorâ”‚ â”‚ Manager â”‚    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  Relic  â”‚ â”‚  Event  â”‚ â”‚  Meta   â”‚ â”‚  Save   â”‚    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â”‚ System  â”‚ â”‚ System  â”‚ â”‚Progress â”‚ â”‚ System  â”‚    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â”‚                                                              â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚                     UI å±‚                              â”‚   â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚   â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â”‚ Battle  â”‚ â”‚   Map   â”‚ â”‚  Card   â”‚ â”‚  Menu   â”‚    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â”‚   UI    â”‚ â”‚   UI    â”‚ â”‚   UI    â”‚ â”‚   UI    â”‚    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â”‚                                                              â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚   â”‚
â”‚  â”‚  â”‚                    æ•°æ®å±‚                              â”‚   â”‚   â”‚
â”‚  â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚   â”‚
â”‚  â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  Cards  â”‚ â”‚ Enemies â”‚ â”‚ Relics  â”‚ â”‚ Events  â”‚    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â”‚  Data   â”‚ â”‚  Data   â”‚ â”‚  Data   â”‚ â”‚  Data   â”‚    â”‚   â”‚   â”‚
â”‚  â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚   â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚   â”‚
â”‚  â”‚                                                              â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                     â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚                    å¾®ä¿¡ API é€‚é…å±‚                           â”‚   â”‚
â”‚  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤   â”‚
â”‚  â”‚  [äº‘å­˜å‚¨] [åˆ†äº«] [å¹¿å‘Š] [æ”¯ä»˜] [æ’è¡Œæ¦œ] [ç”¨æˆ·ä¿¡æ¯]          â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ“ é¡¹ç›®ç»“æ„

```
dungeon-roguelike/
â”œâ”€â”€ assets/
â”‚   â”œâ”€â”€ scripts/
â”‚   â”‚   â”œâ”€â”€ core/                    # æ ¸å¿ƒç³»ç»Ÿ
â”‚   â”‚   â”‚   â”œâ”€â”€ GameManager.ts       # æ¸¸æˆç®¡ç†å™¨(å•ä¾‹)
â”‚   â”‚   â”‚   â”œâ”€â”€ GameStateManager.ts  # çŠ¶æ€æœºç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ EventBus.ts          # äº‹ä»¶æ€»çº¿
â”‚   â”‚   â”‚   â””â”€â”€ ObjectPool.ts        # å¯¹è±¡æ± 
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ battle/                  # æˆ˜æ–—ç³»ç»Ÿ
â”‚   â”‚   â”‚   â”œâ”€â”€ BattleManager.ts     # æˆ˜æ–—ç®¡ç†å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ TurnManager.ts       # å›åˆç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ DamageCalculator.ts  # ä¼¤å®³è®¡ç®—
â”‚   â”‚   â”‚   â”œâ”€â”€ BuffSystem.ts        # Buffç³»ç»Ÿ
â”‚   â”‚   â”‚   â””â”€â”€ ElementSystem.ts     # äº”è¡Œç³»ç»Ÿ
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ card/                    # å¡ç‰Œç³»ç»Ÿ
â”‚   â”‚   â”‚   â”œâ”€â”€ CardManager.ts       # å¡ç‰Œç®¡ç†å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ Card.ts              # å¡ç‰ŒåŸºç±»
â”‚   â”‚   â”‚   â”œâ”€â”€ Deck.ts              # ç‰Œç»„
â”‚   â”‚   â”‚   â”œâ”€â”€ Hand.ts              # æ‰‹ç‰Œ
â”‚   â”‚   â”‚   â””â”€â”€ CardEffects.ts       # å¡ç‰Œæ•ˆæœ
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ dungeon/                 # åœ°ç‰¢ç³»ç»Ÿ
â”‚   â”‚   â”‚   â”œâ”€â”€ DungeonGenerator.ts  # åœ°ç‰¢ç”Ÿæˆå™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ Room.ts              # æˆ¿é—´ç±»
â”‚   â”‚   â”‚   â”œâ”€â”€ Floor.ts             # æ¥¼å±‚ç±»
â”‚   â”‚   â”‚   â””â”€â”€ MapNode.ts           # åœ°å›¾èŠ‚ç‚¹
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ entity/                  # å®ä½“ç³»ç»Ÿ
â”‚   â”‚   â”‚   â”œâ”€â”€ Entity.ts            # å®ä½“åŸºç±»
â”‚   â”‚   â”‚   â”œâ”€â”€ Player.ts            # ç©å®¶
â”‚   â”‚   â”‚   â”œâ”€â”€ Enemy.ts             # æ•Œäºº
â”‚   â”‚   â”‚   â””â”€â”€ EnemyAI.ts           # æ•ŒäººAI
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ relic/                   # é—ç‰©ç³»ç»Ÿ
â”‚   â”‚   â”‚   â”œâ”€â”€ RelicManager.ts      # é—ç‰©ç®¡ç†å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ Relic.ts             # é—ç‰©åŸºç±»
â”‚   â”‚   â”‚   â””â”€â”€ RelicEffects.ts      # é—ç‰©æ•ˆæœ
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ event/                   # äº‹ä»¶ç³»ç»Ÿ
â”‚   â”‚   â”‚   â”œâ”€â”€ EventManager.ts      # äº‹ä»¶ç®¡ç†å™¨
â”‚   â”‚   â”‚   â”œâ”€â”€ RandomEvent.ts       # éšæœºäº‹ä»¶
â”‚   â”‚   â”‚   â””â”€â”€ Shop.ts              # å•†åº—
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ meta/                    # Metaè¿›åº¦
â”‚   â”‚   â”‚   â”œâ”€â”€ MetaProgress.ts      # æ°¸ä¹…è¿›åº¦
â”‚   â”‚   â”‚   â”œâ”€â”€ Achievements.ts      # æˆå°±ç³»ç»Ÿ
â”‚   â”‚   â”‚   â””â”€â”€ Unlocks.ts           # è§£é”ç³»ç»Ÿ
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ save/                    # å­˜æ¡£ç³»ç»Ÿ
â”‚   â”‚   â”‚   â”œâ”€â”€ SaveManager.ts       # å­˜æ¡£ç®¡ç†
â”‚   â”‚   â”‚   â”œâ”€â”€ LocalStorage.ts      # æœ¬åœ°å­˜å‚¨
â”‚   â”‚   â”‚   â””â”€â”€ CloudStorage.ts      # äº‘å­˜å‚¨
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ ui/                      # UIç»„ä»¶
â”‚   â”‚   â”‚   â”œâ”€â”€ BattleUI.ts          # æˆ˜æ–—ç•Œé¢
â”‚   â”‚   â”‚   â”œâ”€â”€ MapUI.ts             # åœ°å›¾ç•Œé¢
â”‚   â”‚   â”‚   â”œâ”€â”€ CardUI.ts            # å¡ç‰ŒUI
â”‚   â”‚   â”‚   â”œâ”€â”€ RewardUI.ts          # å¥–åŠ±ç•Œé¢
â”‚   â”‚   â”‚   â”œâ”€â”€ ShopUI.ts            # å•†åº—ç•Œé¢
â”‚   â”‚   â”‚   â””â”€â”€ MenuUI.ts            # èœå•ç•Œé¢
â”‚   â”‚   â”‚
â”‚   â”‚   â”œâ”€â”€ utils/                   # å·¥å…·ç±»
â”‚   â”‚   â”‚   â”œâ”€â”€ Random.ts            # éšæœºæ•°(å¸¦ç§å­)
â”‚   â”‚   â”‚   â”œâ”€â”€ WeightedRandom.ts    # æƒé‡éšæœº
â”‚   â”‚   â”‚   â””â”€â”€ MathUtils.ts         # æ•°å­¦å·¥å…·
â”‚   â”‚   â”‚
â”‚   â”‚   â””â”€â”€ platform/                # å¹³å°é€‚é…
â”‚   â”‚       â”œâ”€â”€ WechatAdapter.ts     # å¾®ä¿¡é€‚é…
â”‚   â”‚       â”œâ”€â”€ AdManager.ts         # å¹¿å‘Šç®¡ç†
â”‚   â”‚       â””â”€â”€ ShareManager.ts      # åˆ†äº«ç®¡ç†
â”‚   â”‚
â”‚   â”œâ”€â”€ data/                        # æ•°æ®é…ç½®(JSON)
â”‚   â”‚   â”œâ”€â”€ cards/
â”‚   â”‚   â”‚   â”œâ”€â”€ attack_cards.json
â”‚   â”‚   â”‚   â”œâ”€â”€ skill_cards.json
â”‚   â”‚   â”‚   â””â”€â”€ power_cards.json
â”‚   â”‚   â”œâ”€â”€ enemies/
â”‚   â”‚   â”‚   â”œâ”€â”€ floor1_enemies.json
â”‚   â”‚   â”‚   â”œâ”€â”€ floor2_enemies.json
â”‚   â”‚   â”‚   â””â”€â”€ bosses.json
â”‚   â”‚   â”œâ”€â”€ relics/
â”‚   â”‚   â”‚   â””â”€â”€ relics.json
â”‚   â”‚   â”œâ”€â”€ events/
â”‚   â”‚   â”‚   â””â”€â”€ random_events.json
â”‚   â”‚   â””â”€â”€ characters/
â”‚   â”‚       â””â”€â”€ characters.json
â”‚   â”‚
â”‚   â”œâ”€â”€ prefabs/                     # é¢„åˆ¶ä½“
â”‚   â”‚   â”œâ”€â”€ Card.prefab
â”‚   â”‚   â”œâ”€â”€ Enemy.prefab
â”‚   â”‚   â”œâ”€â”€ DamageNumber.prefab
â”‚   â”‚   â””â”€â”€ Effect.prefab
â”‚   â”‚
â”‚   â”œâ”€â”€ textures/                    # å›¾ç‰‡èµ„æº
â”‚   â”‚   â”œâ”€â”€ cards/
â”‚   â”‚   â”œâ”€â”€ enemies/
â”‚   â”‚   â”œâ”€â”€ ui/
â”‚   â”‚   â””â”€â”€ effects/
â”‚   â”‚
â”‚   â”œâ”€â”€ audio/                       # éŸ³é¢‘èµ„æº
â”‚   â”‚   â”œâ”€â”€ bgm/
â”‚   â”‚   â””â”€â”€ sfx/
â”‚   â”‚
â”‚   â””â”€â”€ scenes/                      # åœºæ™¯
â”‚       â”œâ”€â”€ Loading.scene
â”‚       â”œâ”€â”€ MainMenu.scene
â”‚       â”œâ”€â”€ Battle.scene
â”‚       â””â”€â”€ Map.scene
â”‚
â”œâ”€â”€ build/                           # æ„å»ºè¾“å‡º
â”‚   â””â”€â”€ wechatgame/
â”‚
â”œâ”€â”€ settings/                        # é¡¹ç›®è®¾ç½®
â”‚
â”œâ”€â”€ package.json
â””â”€â”€ tsconfig.json
```

---

## ğŸ”§ æ ¸å¿ƒç³»ç»Ÿè®¾è®¡

### 1. æ¸¸æˆçŠ¶æ€æœº

```typescript
// GameStateManager.ts

enum GameState {
  LOADING = 'loading',
  MAIN_MENU = 'main_menu',
  CHARACTER_SELECT = 'character_select',
  MAP = 'map',
  BATTLE = 'battle',
  REWARD = 'reward',
  EVENT = 'event',
  SHOP = 'shop',
  GAME_OVER = 'game_over',
  VICTORY = 'victory'
}

class GameStateManager {
  private currentState: GameState;
  private stateStack: GameState[] = [];

  transition(newState: GameState): void {
    this.stateStack.push(this.currentState);
    this.onExitState(this.currentState);
    this.currentState = newState;
    this.onEnterState(newState);
    EventBus.emit('state_changed', { from: this.stateStack[this.stateStack.length - 1], to: newState });
  }

  back(): void {
    if (this.stateStack.length > 0) {
      const prevState = this.stateStack.pop();
      this.onExitState(this.currentState);
      this.currentState = prevState;
      this.onEnterState(prevState);
    }
  }
}
```

### 2. äº‹ä»¶æ€»çº¿

```typescript
// EventBus.ts

type EventCallback = (...args: any[]) => void;

class EventBus {
  private static listeners: Map<string, EventCallback[]> = new Map();

  static on(event: string, callback: EventCallback): void {
    if (!this.listeners.has(event)) {
      this.listeners.set(event, []);
    }
    this.listeners.get(event).push(callback);
  }

  static off(event: string, callback: EventCallback): void {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      const index = callbacks.indexOf(callback);
      if (index > -1) callbacks.splice(index, 1);
    }
  }

  static emit(event: string, ...args: any[]): void {
    const callbacks = this.listeners.get(event);
    if (callbacks) {
      callbacks.forEach(cb => cb(...args));
    }
  }

  static clear(): void {
    this.listeners.clear();
  }
}

// äº‹ä»¶ç±»å‹å¸¸é‡
const GameEvents = {
  // æˆ˜æ–—ç›¸å…³
  BATTLE_START: 'battle_start',
  BATTLE_END: 'battle_end',
  TURN_START: 'turn_start',
  TURN_END: 'turn_end',
  PLAYER_TURN_START: 'player_turn_start',
  ENEMY_TURN_START: 'enemy_turn_start',

  // å¡ç‰Œç›¸å…³
  CARD_DRAWN: 'card_drawn',
  CARD_PLAYED: 'card_played',
  CARD_DISCARDED: 'card_discarded',
  CARD_EXHAUSTED: 'card_exhausted',
  CARD_ADDED: 'card_added',

  // ä¼¤å®³/æ²»ç–—
  DAMAGE_DEALT: 'damage_dealt',
  DAMAGE_TAKEN: 'damage_taken',
  HEAL: 'heal',
  ARMOR_GAINED: 'armor_gained',

  // çŠ¶æ€æ•ˆæœ
  BUFF_APPLIED: 'buff_applied',
  BUFF_REMOVED: 'buff_removed',
  DEBUFF_APPLIED: 'debuff_applied',

  // åœ°ç‰¢è¿›åº¦
  ROOM_ENTERED: 'room_entered',
  FLOOR_CLEARED: 'floor_cleared',
  BOSS_DEFEATED: 'boss_defeated',

  // å¥–åŠ±
  GOLD_GAINED: 'gold_gained',
  RELIC_OBTAINED: 'relic_obtained',
  CARD_OBTAINED: 'card_obtained',

  // è§’è‰²
  PLAYER_DIED: 'player_died',
  ENEMY_DIED: 'enemy_died'
};
```

### 3. æˆ˜æ–—ç³»ç»Ÿ

```typescript
// BattleManager.ts

interface BattleState {
  player: Player;
  enemies: Enemy[];
  turn: number;
  phase: 'player' | 'enemy';
  isActive: boolean;
}

class BattleManager {
  private state: BattleState;
  private turnManager: TurnManager;
  private damageCalculator: DamageCalculator;

  startBattle(enemies: Enemy[]): void {
    this.state = {
      player: GameManager.instance.player,
      enemies: enemies,
      turn: 0,
      phase: 'player',
      isActive: true
    };

    this.state.player.deck.shuffle();
    this.drawCards(5);
    this.startPlayerTurn();

    EventBus.emit(GameEvents.BATTLE_START, { enemies });
  }

  startPlayerTurn(): void {
    this.state.turn++;
    this.state.phase = 'player';

    // é‡ç½®èƒ½é‡
    this.state.player.energy = this.state.player.maxEnergy;

    // åº”ç”¨å›åˆå¼€å§‹æ•ˆæœ
    this.applyTurnStartEffects(this.state.player);

    // æŠ½ç‰Œ
    this.drawCards(5);

    EventBus.emit(GameEvents.PLAYER_TURN_START, { turn: this.state.turn });
  }

  endPlayerTurn(): void {
    // å¼ƒæ‰æ‰‹ç‰Œ
    this.state.player.hand.discardAll();

    // åº”ç”¨å›åˆç»“æŸæ•ˆæœ
    this.applyTurnEndEffects(this.state.player);

    // æŠ¤ç”²è¡°å‡(å¯é€‰è§„åˆ™)
    // this.state.player.armor = 0;

    this.startEnemyTurn();
  }

  async startEnemyTurn(): Promise<void> {
    this.state.phase = 'enemy';
    EventBus.emit(GameEvents.ENEMY_TURN_START);

    for (const enemy of this.state.enemies) {
      if (enemy.isAlive()) {
        await this.executeEnemyAction(enemy);
      }
    }

    // æ£€æŸ¥ç©å®¶æ˜¯å¦å­˜æ´»
    if (this.state.player.hp <= 0) {
      this.endBattle(false);
      return;
    }

    this.startPlayerTurn();
  }

  playCard(card: Card, target?: Entity): boolean {
    if (this.state.phase !== 'player') return false;
    if (this.state.player.energy < card.cost) return false;

    // æ¶ˆè€—èƒ½é‡
    this.state.player.energy -= card.cost;

    // æ‰§è¡Œå¡ç‰Œæ•ˆæœ
    card.play(this.state.player, target, this.state.enemies);

    // ç§»åŠ¨åˆ°å¼ƒç‰Œå †(é™¤éæ˜¯æ¶ˆè€—ç‰Œ)
    if (card.exhaust) {
      this.state.player.hand.exhaust(card);
    } else {
      this.state.player.hand.discard(card);
    }

    EventBus.emit(GameEvents.CARD_PLAYED, { card, target });

    // æ£€æŸ¥æˆ˜æ–—æ˜¯å¦ç»“æŸ
    this.checkBattleEnd();

    return true;
  }

  private checkBattleEnd(): void {
    const allEnemiesDead = this.state.enemies.every(e => !e.isAlive());
    if (allEnemiesDead) {
      this.endBattle(true);
    }
  }

  private endBattle(victory: boolean): void {
    this.state.isActive = false;
    EventBus.emit(GameEvents.BATTLE_END, { victory });

    if (victory) {
      GameStateManager.transition(GameState.REWARD);
    } else {
      GameStateManager.transition(GameState.GAME_OVER);
    }
  }
}
```

### 4. å¡ç‰Œç³»ç»Ÿ

```typescript
// Card.ts

enum CardType {
  ATTACK = 'attack',
  SKILL = 'skill',
  POWER = 'power',
  STATUS = 'status',
  CURSE = 'curse'
}

enum CardRarity {
  COMMON = 'common',
  UNCOMMON = 'uncommon',
  RARE = 'rare',
  LEGENDARY = 'legendary'
}

enum Element {
  NONE = 'none',
  METAL = 'metal',
  WOOD = 'wood',
  WATER = 'water',
  FIRE = 'fire',
  EARTH = 'earth'
}

interface CardData {
  id: string;
  name: string;
  description: string;
  type: CardType;
  rarity: CardRarity;
  cost: number;
  element: Element;
  exhaust: boolean;
  upgradable: boolean;
  effects: CardEffect[];
}

abstract class Card {
  id: string;
  name: string;
  description: string;
  type: CardType;
  rarity: CardRarity;
  cost: number;
  element: Element;
  exhaust: boolean;
  upgraded: boolean = false;

  constructor(data: CardData) {
    Object.assign(this, data);
  }

  abstract play(owner: Player, target: Entity | null, allEnemies: Enemy[]): void;

  upgrade(): void {
    if (this.upgraded) return;
    this.upgraded = true;
    this.applyUpgrade();
  }

  protected abstract applyUpgrade(): void;

  getDisplayDescription(): string {
    // æ›¿æ¢å˜é‡æ˜¾ç¤ºå®é™…æ•°å€¼
    return this.description
      .replace('{damage}', this.getDamage().toString())
      .replace('{armor}', this.getArmor().toString());
  }

  protected getDamage(): number { return 0; }
  protected getArmor(): number { return 0; }
}

// å…·ä½“å¡ç‰Œå®ç°ç¤ºä¾‹
class StrikeCard extends Card {
  private baseDamage: number = 6;

  play(owner: Player, target: Entity): void {
    const damage = this.baseDamage + owner.strength;
    DamageCalculator.dealDamage(owner, target, damage, this.element);
  }

  protected applyUpgrade(): void {
    this.baseDamage = 9;
    this.name = "æ¨ªåŠˆ+";
  }

  protected getDamage(): number {
    return this.baseDamage;
  }
}

class DefendCard extends Card {
  private baseArmor: number = 5;

  play(owner: Player): void {
    const armor = this.baseArmor + owner.dexterity;
    owner.gainArmor(armor);
  }

  protected applyUpgrade(): void {
    this.baseArmor = 8;
    this.name = "é“å£+";
  }

  protected getArmor(): number {
    return this.baseArmor;
  }
}
```

### 5. åœ°ç‰¢ç”Ÿæˆå™¨

```typescript
// DungeonGenerator.ts

interface MapNode {
  id: string;
  type: RoomType;
  position: { x: number, y: number };
  connections: string[];
  visited: boolean;
  cleared: boolean;
}

enum RoomType {
  START = 'start',
  BATTLE = 'battle',
  ELITE = 'elite',
  BOSS = 'boss',
  SHOP = 'shop',
  REST = 'rest',
  EVENT = 'event',
  TREASURE = 'treasure'
}

class DungeonGenerator {
  private floorConfig: FloorConfig;

  generate(floor: number): MapNode[] {
    this.floorConfig = FLOOR_CONFIGS[floor];

    const nodes: MapNode[] = [];
    const rows = this.floorConfig.rows;
    const nodesPerRow = this.floorConfig.nodesPerRow;

    // ç”Ÿæˆèµ·ç‚¹
    nodes.push(this.createNode('start_0', RoomType.START, 0, Math.floor(nodesPerRow / 2)));

    // ç”Ÿæˆä¸­é—´å±‚
    for (let row = 1; row < rows - 1; row++) {
      const count = this.getNodesForRow(row);
      const offset = Math.floor((nodesPerRow - count) / 2);

      for (let col = 0; col < count; col++) {
        const type = this.getRandomRoomType(row, floor);
        nodes.push(this.createNode(`node_${row}_${col}`, type, row, col + offset));
      }
    }

    // ç”ŸæˆBOSSæˆ¿
    nodes.push(this.createNode('boss_0', RoomType.BOSS, rows - 1, Math.floor(nodesPerRow / 2)));

    // ç”Ÿæˆè¿æ¥
    this.generateConnections(nodes, rows);

    // ç¡®ä¿è·¯å¾„è¿é€šæ€§
    this.ensurePathExists(nodes);

    return nodes;
  }

  private getRandomRoomType(row: number, floor: number): RoomType {
    const weights = this.floorConfig.roomWeights;

    // ç²¾è‹±æˆ¿åªåœ¨ç‰¹å®šè¡Œå‡ºç°
    if (row === Math.floor(this.floorConfig.rows / 2)) {
      if (Random.chance(0.3)) return RoomType.ELITE;
    }

    // ä¼‘æ¯ç‚¹åœ¨ååŠæ®µå‡ºç°
    if (row > this.floorConfig.rows * 0.6) {
      if (Random.chance(0.2)) return RoomType.REST;
    }

    return WeightedRandom.pick([
      { value: RoomType.BATTLE, weight: weights.battle },
      { value: RoomType.EVENT, weight: weights.event },
      { value: RoomType.SHOP, weight: weights.shop },
      { value: RoomType.TREASURE, weight: weights.treasure }
    ]);
  }

  private generateConnections(nodes: MapNode[], rows: number): void {
    for (let row = 0; row < rows - 1; row++) {
      const currentRowNodes = nodes.filter(n => n.position.y === row);
      const nextRowNodes = nodes.filter(n => n.position.y === row + 1);

      for (const node of currentRowNodes) {
        // æ¯ä¸ªèŠ‚ç‚¹è¿æ¥1-3ä¸ªä¸‹ä¸€è¡ŒèŠ‚ç‚¹
        const connectionCount = Random.int(1, Math.min(3, nextRowNodes.length));
        const nearbyNodes = this.getNearbyNodes(node, nextRowNodes);

        for (let i = 0; i < connectionCount && i < nearbyNodes.length; i++) {
          node.connections.push(nearbyNodes[i].id);
        }
      }
    }
  }

  private getNearbyNodes(node: MapNode, candidates: MapNode[]): MapNode[] {
    return candidates
      .filter(n => Math.abs(n.position.x - node.position.x) <= 1)
      .sort((a, b) =>
        Math.abs(a.position.x - node.position.x) -
        Math.abs(b.position.x - node.position.x)
      );
  }
}

// æ¥¼å±‚é…ç½®
const FLOOR_CONFIGS: Record<number, FloorConfig> = {
  1: {
    name: "åœŸç‰¢",
    rows: 8,
    nodesPerRow: 4,
    roomWeights: { battle: 60, event: 15, shop: 10, treasure: 10, rest: 5 },
    enemyPool: ['slime', 'skeleton', 'goblin'],
    elitePool: ['stone_golem'],
    boss: 'earth_titan'
  },
  2: {
    name: "æ°´ç‹±",
    rows: 10,
    nodesPerRow: 5,
    roomWeights: { battle: 55, event: 18, shop: 12, treasure: 8, rest: 7 },
    enemyPool: ['water_sprite', 'kraken_spawn', 'sirens'],
    elitePool: ['sea_serpent'],
    boss: 'abyssal_lord'
  }
  // ... æ›´å¤šæ¥¼å±‚
};
```

### 6. æ•ŒäººAIç³»ç»Ÿ

```typescript
// EnemyAI.ts

interface EnemyIntent {
  type: 'attack' | 'defend' | 'buff' | 'debuff' | 'summon' | 'special';
  value?: number;
  target?: Entity;
  description: string;
  icon: string;
}

abstract class EnemyAI {
  protected enemy: Enemy;
  protected intentHistory: EnemyIntent[] = [];

  constructor(enemy: Enemy) {
    this.enemy = enemy;
  }

  abstract decideIntent(): EnemyIntent;
  abstract executeIntent(intent: EnemyIntent): void;

  protected getRandomIntent(options: Array<{ intent: EnemyIntent, weight: number }>): EnemyIntent {
    return WeightedRandom.pick(options.map(o => ({ value: o.intent, weight: o.weight })));
  }
}

class BasicEnemyAI extends EnemyAI {
  private patterns: EnemyIntent[] = [];
  private patternIndex: number = 0;

  constructor(enemy: Enemy, patterns: EnemyIntent[]) {
    super(enemy);
    this.patterns = patterns;
  }

  decideIntent(): EnemyIntent {
    const intent = this.patterns[this.patternIndex];
    this.patternIndex = (this.patternIndex + 1) % this.patterns.length;
    return intent;
  }

  executeIntent(intent: EnemyIntent): void {
    switch (intent.type) {
      case 'attack':
        DamageCalculator.dealDamage(this.enemy, GameManager.instance.player, intent.value);
        break;
      case 'defend':
        this.enemy.gainArmor(intent.value);
        break;
      case 'buff':
        this.enemy.applyBuff(intent.buffType, intent.value);
        break;
      case 'debuff':
        GameManager.instance.player.applyDebuff(intent.debuffType, intent.value);
        break;
    }
  }
}

class BossAI extends EnemyAI {
  private phase: number = 1;
  private turnCount: number = 0;

  decideIntent(): EnemyIntent {
    this.updatePhase();
    return this.getPhaseIntent();
  }

  private updatePhase(): void {
    const hpPercent = this.enemy.hp / this.enemy.maxHp;
    if (hpPercent <= 0.25) this.phase = 3;
    else if (hpPercent <= 0.5) this.phase = 2;
    else this.phase = 1;
  }

  private getPhaseIntent(): EnemyIntent {
    switch (this.phase) {
      case 1:
        return this.getPhase1Intent();
      case 2:
        return this.getPhase2Intent();
      case 3:
        return this.getPhase3Intent();
    }
  }

  // å­ç±»å®ç°å…·ä½“BOSSè¡Œä¸º
  protected abstract getPhase1Intent(): EnemyIntent;
  protected abstract getPhase2Intent(): EnemyIntent;
  protected abstract getPhase3Intent(): EnemyIntent;
}
```

---

## ğŸ’¾ æ•°æ®é…ç½®æ ¼å¼

### å¡ç‰Œæ•°æ® (JSON)

```json
// cards/attack_cards.json
{
  "cards": [
    {
      "id": "strike",
      "name": "æ¨ªåŠˆ",
      "nameUpgraded": "æ¨ªåŠˆ+",
      "description": "é€ æˆ{damage}ç‚¹ä¼¤å®³",
      "type": "attack",
      "rarity": "common",
      "cost": 1,
      "costUpgraded": 1,
      "element": "none",
      "exhaust": false,
      "effects": [
        { "type": "damage", "value": 6, "valueUpgraded": 9, "target": "single" }
      ]
    },
    {
      "id": "heavy_blow",
      "name": "é‡å‡»",
      "nameUpgraded": "é‡å‡»+",
      "description": "é€ æˆ{damage}ç‚¹ä¼¤å®³ï¼Œè‹¥æ•Œäººæœ‰æ˜“ä¼¤ï¼Œé¢å¤–é€ æˆ{bonus}ç‚¹ä¼¤å®³",
      "type": "attack",
      "rarity": "uncommon",
      "cost": 2,
      "element": "metal",
      "effects": [
        { "type": "damage", "value": 12, "valueUpgraded": 16, "target": "single" },
        { "type": "conditional_damage", "condition": "vulnerable", "value": 5, "valueUpgraded": 8 }
      ]
    },
    {
      "id": "whirlwind",
      "name": "æ—‹é£æ–©",
      "description": "æ¶ˆè€—æ‰€æœ‰èƒ½é‡ï¼Œå¯¹æ‰€æœ‰æ•Œäººé€ æˆ{damage}xèƒ½é‡ç‚¹ä¼¤å®³",
      "type": "attack",
      "rarity": "rare",
      "cost": -1,
      "element": "wood",
      "effects": [
        { "type": "damage_per_energy", "value": 5, "valueUpgraded": 8, "target": "all" }
      ]
    }
  ]
}
```

### æ•Œäººæ•°æ® (JSON)

```json
// enemies/floor1_enemies.json
{
  "enemies": [
    {
      "id": "slime",
      "name": "å²è±å§†",
      "hp": { "min": 15, "max": 20 },
      "element": "water",
      "aiType": "pattern",
      "patterns": [
        { "type": "attack", "value": 5, "icon": "sword" },
        { "type": "attack", "value": 5, "icon": "sword" },
        { "type": "defend", "value": 4, "icon": "shield" }
      ],
      "drops": {
        "gold": { "min": 5, "max": 15 },
        "cardChance": 0.3
      }
    },
    {
      "id": "skeleton",
      "name": "éª·é«…å…µ",
      "hp": { "min": 28, "max": 35 },
      "element": "earth",
      "aiType": "weighted",
      "actions": [
        { "type": "attack", "value": 8, "weight": 50, "icon": "sword" },
        { "type": "defend", "value": 6, "weight": 30, "icon": "shield" },
        { "type": "debuff", "effect": "weak", "value": 1, "weight": 20, "icon": "skull" }
      ]
    }
  ],

  "elites": [
    {
      "id": "stone_golem",
      "name": "çŸ³å‚€å„¡",
      "hp": { "min": 80, "max": 100 },
      "element": "earth",
      "aiType": "boss",
      "phases": [
        {
          "threshold": 1.0,
          "actions": [
            { "type": "attack", "value": 12, "weight": 40 },
            { "type": "defend", "value": 15, "weight": 40 },
            { "type": "buff", "effect": "strength", "value": 2, "weight": 20 }
          ]
        },
        {
          "threshold": 0.5,
          "actions": [
            { "type": "attack", "value": 18, "weight": 50 },
            { "type": "special", "effect": "quake", "value": 8, "target": "all", "weight": 50 }
          ]
        }
      ],
      "drops": {
        "gold": { "min": 30, "max": 50 },
        "relicChance": 0.5
      }
    }
  ]
}
```

---

## ğŸ“± å¾®ä¿¡å°æ¸¸æˆé€‚é…

### å¹³å°é€‚é…å™¨

```typescript
// WechatAdapter.ts

class WechatAdapter {
  private static instance: WechatAdapter;

  // åˆå§‹åŒ–
  async init(): Promise<void> {
    // è·å–ç³»ç»Ÿä¿¡æ¯
    const systemInfo = wx.getSystemInfoSync();
    GameManager.instance.setScreenSize(systemInfo.windowWidth, systemInfo.windowHeight);

    // åˆå§‹åŒ–äº‘å¼€å‘
    wx.cloud.init({
      env: 'your-env-id'
    });

    // åˆå§‹åŒ–å¹¿å‘Š
    await AdManager.init();

    // åŠ è½½ç”¨æˆ·æ•°æ®
    await this.loadUserData();
  }

  // äº‘å­˜æ¡£
  async saveToCloud(data: SaveData): Promise<void> {
    const db = wx.cloud.database();
    const userInfo = await this.getUserInfo();

    await db.collection('saves').where({
      openId: userInfo.openId
    }).update({
      data: {
        saveData: data,
        updateTime: new Date()
      }
    });
  }

  async loadFromCloud(): Promise<SaveData | null> {
    const db = wx.cloud.database();
    const userInfo = await this.getUserInfo();

    const result = await db.collection('saves').where({
      openId: userInfo.openId
    }).get();

    return result.data[0]?.saveData || null;
  }

  // åˆ†äº«
  shareAppMessage(title: string, imageUrl: string, query?: string): void {
    wx.shareAppMessage({
      title,
      imageUrl,
      query
    });
  }

  // æ˜¾ç¤ºæ¿€åŠ±å¹¿å‘Š
  async showRewardedAd(): Promise<boolean> {
    return AdManager.showRewardedAd();
  }

  // æ’è¡Œæ¦œ
  async submitScore(score: number): Promise<void> {
    const kvData = {
      wxgame: {
        score,
        update_time: Date.now()
      }
    };

    wx.setUserCloudStorage({
      KVDataList: [{ key: 'score', value: JSON.stringify(kvData) }]
    });
  }
}
```

### å¹¿å‘Šç®¡ç†å™¨

```typescript
// AdManager.ts

class AdManager {
  private static rewardedAd: WechatMinigame.RewardedVideoAd | null = null;
  private static bannerAd: WechatMinigame.BannerAd | null = null;

  static async init(): Promise<void> {
    // åˆ›å»ºæ¿€åŠ±è§†é¢‘å¹¿å‘Š
    if (wx.createRewardedVideoAd) {
      this.rewardedAd = wx.createRewardedVideoAd({
        adUnitId: 'your-rewarded-ad-id'
      });

      this.rewardedAd.onError((err) => {
        console.error('æ¿€åŠ±å¹¿å‘ŠåŠ è½½å¤±è´¥', err);
      });
    }

    // é¢„åŠ è½½å¹¿å‘Š
    await this.preloadRewardedAd();
  }

  static async showRewardedAd(): Promise<boolean> {
    if (!this.rewardedAd) return false;

    return new Promise((resolve) => {
      const onClose = (res: { isEnded: boolean }) => {
        this.rewardedAd.offClose(onClose);
        resolve(res.isEnded);

        // é¢„åŠ è½½ä¸‹ä¸€ä¸ªå¹¿å‘Š
        this.preloadRewardedAd();
      };

      this.rewardedAd.onClose(onClose);

      this.rewardedAd.show().catch(() => {
        // å¹¿å‘ŠæœªåŠ è½½å®Œæˆï¼Œå°è¯•é‡æ–°åŠ è½½
        this.rewardedAd.load().then(() => {
          this.rewardedAd.show();
        }).catch(() => {
          resolve(false);
        });
      });
    });
  }

  private static async preloadRewardedAd(): Promise<void> {
    if (this.rewardedAd) {
      await this.rewardedAd.load().catch(() => {});
    }
  }
}
```

---

## ğŸ¯ æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

### 1. å¯¹è±¡æ± 

```typescript
// ObjectPool.ts

class ObjectPool<T> {
  private pool: T[] = [];
  private createFn: () => T;
  private resetFn: (obj: T) => void;

  constructor(createFn: () => T, resetFn: (obj: T) => void, initialSize: number = 10) {
    this.createFn = createFn;
    this.resetFn = resetFn;

    // é¢„åˆ›å»ºå¯¹è±¡
    for (let i = 0; i < initialSize; i++) {
      this.pool.push(this.createFn());
    }
  }

  get(): T {
    if (this.pool.length > 0) {
      return this.pool.pop()!;
    }
    return this.createFn();
  }

  release(obj: T): void {
    this.resetFn(obj);
    this.pool.push(obj);
  }

  clear(): void {
    this.pool = [];
  }
}

// ä½¿ç”¨ç¤ºä¾‹
const damageNumberPool = new ObjectPool(
  () => new DamageNumber(),
  (dn) => dn.reset(),
  20
);
```

### 2. èµ„æºç®¡ç†

```typescript
// ResourceManager.ts

class ResourceManager {
  private static loadedResources: Map<string, any> = new Map();
  private static loadingPromises: Map<string, Promise<any>> = new Map();

  // é¢„åŠ è½½èµ„æº
  static async preload(resources: string[]): Promise<void> {
    const promises = resources.map(res => this.load(res));
    await Promise.all(promises);
  }

  // åŠ è½½å•ä¸ªèµ„æº
  static async load<T>(path: string): Promise<T> {
    // å·²åŠ è½½
    if (this.loadedResources.has(path)) {
      return this.loadedResources.get(path);
    }

    // æ­£åœ¨åŠ è½½
    if (this.loadingPromises.has(path)) {
      return this.loadingPromises.get(path);
    }

    // å¼€å§‹åŠ è½½
    const promise = new Promise<T>((resolve, reject) => {
      cc.resources.load(path, (err, asset) => {
        if (err) {
          reject(err);
        } else {
          this.loadedResources.set(path, asset);
          resolve(asset as T);
        }
        this.loadingPromises.delete(path);
      });
    });

    this.loadingPromises.set(path, promise);
    return promise;
  }

  // é‡Šæ”¾èµ„æº
  static release(path: string): void {
    if (this.loadedResources.has(path)) {
      const asset = this.loadedResources.get(path);
      cc.resources.release(path);
      this.loadedResources.delete(path);
    }
  }

  // é‡Šæ”¾åœºæ™¯èµ„æº
  static releaseSceneResources(scene: string): void {
    // æ ¹æ®åœºæ™¯é‡Šæ”¾ä¸å†éœ€è¦çš„èµ„æº
  }
}
```

### 3. æ¸²æŸ“ä¼˜åŒ–

```typescript
// åˆæ‰¹ä¼˜åŒ–
// 1. ä½¿ç”¨å›¾é›† (Sprite Atlas)
// 2. ç›¸åŒæè´¨çš„ç²¾çµæ”¾åœ¨ä¸€èµ·
// 3. å‡å°‘åŠ¨æ€åˆæ‰¹æ‰“æ–­

// å¡ç‰Œæ¸²æŸ“ä¼˜åŒ–
class CardRenderer {
  private cardAtlas: cc.SpriteAtlas;
  private cardPool: ObjectPool<cc.Node>;

  // æ‰¹é‡æ›´æ–°å¡ç‰Œæ˜¾ç¤º
  updateHand(cards: Card[]): void {
    // å…ˆéšè—æ‰€æœ‰
    this.hideAllCards();

    // æŒ‰é¡ºåºæ˜¾ç¤º
    cards.forEach((card, index) => {
      const cardNode = this.cardPool.get();
      this.setupCard(cardNode, card, index);
    });
  }

  // ä½¿ç”¨å›¾é›†ä¸­çš„ç²¾çµ
  private getCardSprite(cardId: string): cc.SpriteFrame {
    return this.cardAtlas.getSpriteFrame(cardId);
  }
}
```

---

## ğŸ“Š å†…å­˜ç®¡ç†

```typescript
// MemoryManager.ts

class MemoryManager {
  private static readonly MEMORY_WARNING_THRESHOLD = 0.8; // 80%

  static init(): void {
    // ç›‘å¬å†…å­˜è­¦å‘Š
    if (wx.onMemoryWarning) {
      wx.onMemoryWarning(() => {
        this.onMemoryWarning();
      });
    }

    // å®šæœŸæ£€æŸ¥å†…å­˜
    setInterval(() => {
      this.checkMemory();
    }, 30000); // 30ç§’æ£€æŸ¥ä¸€æ¬¡
  }

  private static onMemoryWarning(): void {
    console.warn('æ”¶åˆ°å†…å­˜è­¦å‘Šï¼Œæ‰§è¡Œæ¸…ç†');

    // æ¸…ç†å¯¹è±¡æ± 
    ObjectPoolManager.shrinkAll();

    // é‡Šæ”¾æœªä½¿ç”¨çš„èµ„æº
    ResourceManager.releaseUnused();

    // è§¦å‘åƒåœ¾å›æ”¶(å¦‚æœå¯ç”¨)
    if (typeof gc === 'function') {
      gc();
    }
  }

  private static checkMemory(): void {
    const info = wx.getPerformance?.()?.memory;
    if (info) {
      const usage = info.usedJSHeapSize / info.totalJSHeapSize;
      if (usage > this.MEMORY_WARNING_THRESHOLD) {
        this.onMemoryWarning();
      }
    }
  }
}
```

---

*æŠ€æœ¯æ¶æ„æ–‡æ¡£ v1.0*
