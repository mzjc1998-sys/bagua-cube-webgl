<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Âú∞Áâ¢Êé¢Á¥¢ - Roguelike</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: #1a1a2e;
      font-family: system-ui, -apple-system, sans-serif;
      touch-action: none;
      user-select: none;
    }
    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    /* HUD */
    #hud {
      position: fixed;
      top: 10px;
      left: 10px;
      right: 10px;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      pointer-events: none;
      z-index: 100;
    }

    .hud-panel {
      background: rgba(0,0,0,0.7);
      border-radius: 12px;
      padding: 10px 15px;
      color: #fff;
      backdrop-filter: blur(5px);
    }

    .health-bar {
      width: 150px;
      height: 20px;
      background: #333;
      border-radius: 10px;
      overflow: hidden;
      margin-top: 5px;
    }

    .health-fill {
      height: 100%;
      background: linear-gradient(90deg, #ff4757, #ff6b81);
      transition: width 0.3s;
    }

    .stats {
      font-size: 14px;
      margin-top: 8px;
    }

    .stats span {
      display: inline-block;
      margin-right: 12px;
    }

    /* ÊîªÂáªÊåâÈíÆ */
    #attackBtn {
      position: fixed;
      bottom: 40px;
      right: 40px;
      width: 100px;
      height: 100px;
      border-radius: 50%;
      background: linear-gradient(145deg, #e74c3c, #c0392b);
      border: 4px solid rgba(255,255,255,0.3);
      color: #fff;
      font-size: 18px;
      font-weight: bold;
      cursor: pointer;
      touch-action: none;
      z-index: 100;
      display: flex;
      align-items: center;
      justify-content: center;
      box-shadow: 0 6px 20px rgba(231,76,60,0.5);
      transition: transform 0.1s, box-shadow 0.1s;
    }

    #attackBtn:active, #attackBtn.active {
      transform: scale(0.95);
      box-shadow: 0 3px 10px rgba(231,76,60,0.5);
    }

    #attackBtn .arrow {
      position: absolute;
      font-size: 24px;
      opacity: 0;
      transition: opacity 0.2s;
    }

    #attackBtn.dragging .arrow {
      opacity: 1;
    }

    #attackBtn.dragging .label {
      opacity: 0.5;
    }

    /* ËôöÊãüÊëáÊùÜ */
    #joystickArea {
      position: fixed;
      bottom: 40px;
      left: 40px;
      width: 120px;
      height: 120px;
      border-radius: 50%;
      background: rgba(255,255,255,0.1);
      border: 3px solid rgba(255,255,255,0.3);
      touch-action: none;
      z-index: 100;
    }

    #joystickKnob {
      position: absolute;
      width: 50px;
      height: 50px;
      border-radius: 50%;
      background: rgba(255,255,255,0.8);
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      pointer-events: none;
    }

    /* Â∞èÂú∞Âõæ */
    #minimap {
      position: fixed;
      top: 10px;
      right: 10px;
      width: 120px;
      height: 120px;
      background: rgba(0,0,0,0.7);
      border-radius: 8px;
      border: 2px solid rgba(255,255,255,0.3);
      z-index: 100;
    }

    #minimapCanvas {
      width: 100%;
      height: 100%;
      border-radius: 6px;
    }

    /* ‰º§ÂÆ≥Êï∞Â≠ó */
    .damage-number {
      position: fixed;
      color: #ff4757;
      font-size: 20px;
      font-weight: bold;
      pointer-events: none;
      animation: damageFloat 1s forwards;
      text-shadow: 0 0 5px #000;
      z-index: 200;
    }

    @keyframes damageFloat {
      0% { opacity: 1; transform: translateY(0); }
      100% { opacity: 0; transform: translateY(-50px); }
    }

    /* Ê∏∏ÊàèÁªìÊùü */
    #gameOver {
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 500;
      color: #fff;
    }

    #gameOver h1 {
      font-size: 48px;
      color: #ff4757;
      margin-bottom: 20px;
    }

    #gameOver .stats-final {
      font-size: 20px;
      margin-bottom: 30px;
      text-align: center;
    }

    #restartBtn {
      padding: 15px 40px;
      font-size: 20px;
      background: linear-gradient(145deg, #27ae60, #2ecc71);
      border: none;
      border-radius: 30px;
      color: #fff;
      cursor: pointer;
      box-shadow: 0 5px 20px rgba(46,204,113,0.4);
    }

    /* Â±ÇÁ∫ßÊèêÁ§∫ */
    #levelIndicator {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 48px;
      color: #fff;
      text-shadow: 0 0 20px rgba(255,255,255,0.5);
      opacity: 0;
      pointer-events: none;
      z-index: 300;
      transition: opacity 0.5s;
    }

    #levelIndicator.show {
      opacity: 1;
    }
  </style>
</head>
<body>

<canvas id="gameCanvas"></canvas>

<div id="hud">
  <div class="hud-panel">
    <div>‚ù§Ô∏è ÁîüÂëΩÂÄº</div>
    <div class="health-bar">
      <div class="health-fill" id="healthFill"></div>
    </div>
    <div class="stats">
      <span>‚öîÔ∏è ÊîªÂáª: <b id="atkStat">10</b></span>
      <span>üõ°Ô∏è Èò≤Âæ°: <b id="defStat">5</b></span>
      <span>üèÜ Â±ÇÊï∞: <b id="floorStat">1</b></span>
      <span>üíÄ ÂáªÊùÄ: <b id="killStat">0</b></span>
    </div>
  </div>
</div>

<div id="minimap">
  <canvas id="minimapCanvas"></canvas>
</div>

<div id="joystickArea">
  <div id="joystickKnob"></div>
</div>

<div id="attackBtn">
  <span class="label">ÊîªÂáª</span>
  <span class="arrow" style="top:-10px;left:50%;transform:translateX(-50%)">‚Üë</span>
  <span class="arrow" style="bottom:-10px;left:50%;transform:translateX(-50%)">‚Üì</span>
  <span class="arrow" style="left:-10px;top:50%;transform:translateY(-50%)">‚Üê</span>
  <span class="arrow" style="right:-10px;top:50%;transform:translateY(-50%)">‚Üí</span>
</div>

<div id="levelIndicator">Á¨¨ 1 Â±Ç</div>

<div id="gameOver">
  <h1>Ê∏∏ÊàèÁªìÊùü</h1>
  <div class="stats-final">
    <div>Âà∞ËææÂ±ÇÊï∞: <b id="finalFloor">1</b></div>
    <div>ÂáªÊùÄÊïå‰∫∫: <b id="finalKills">0</b></div>
  </div>
  <button id="restartBtn">ÈáçÊñ∞ÂºÄÂßã</button>
</div>

<script>
(function() {
  'use strict';

  // ============ Ê∏∏ÊàèÈÖçÁΩÆ ============
  const CONFIG = {
    TILE_SIZE: 40,
    MAP_WIDTH: 30,
    MAP_HEIGHT: 30,
    ROOM_MIN_SIZE: 4,
    ROOM_MAX_SIZE: 8,
    MAX_ROOMS: 12,
    ENEMY_BASE_COUNT: 5,
    ATTACK_RANGE: 60,
    ATTACK_COOLDOWN: 400,
    AUTO_ATTACK_INTERVAL: 500,
    PLAYER_SPEED: 4,
    ENEMY_SPEED: 1.5,
  };

  // ============ Áì¶ÁâáÁ±ªÂûã ============
  const TILE = {
    WALL: 0,
    FLOOR: 1,
    STAIRS: 2,
  };

  // ============ È¢úËâ≤ ============
  const COLORS = {
    WALL: '#2d3436',
    WALL_TOP: '#636e72',
    FLOOR: '#4a4a5e',
    FLOOR_ALT: '#3d3d4d',
    STAIRS: '#f1c40f',
    PLAYER: '#3498db',
    PLAYER_OUTLINE: '#2980b9',
    ENEMY: '#e74c3c',
    ENEMY_OUTLINE: '#c0392b',
    ATTACK: 'rgba(255, 200, 100, 0.6)',
    HEALTH_BG: '#333',
    HEALTH_FILL: '#e74c3c',
  };

  // ============ Ê∏∏ÊàèÁä∂ÊÄÅ ============
  const game = {
    canvas: null,
    ctx: null,
    minimapCanvas: null,
    minimapCtx: null,
    width: 0,
    height: 0,
    dpr: 1,
    map: [],
    rooms: [],
    player: null,
    enemies: [],
    projectiles: [],
    particles: [],
    camera: { x: 0, y: 0 },
    floor: 1,
    kills: 0,
    gameOver: false,
    lastTime: 0,
    joystick: { active: false, dx: 0, dy: 0 },
    attack: {
      active: false,
      direction: null,
      lastTime: 0,
      isHolding: false,
      holdStartTime: 0,
      dragStart: null,
    },
  };

  // ============ Áé©ÂÆ∂Á±ª ============
  class Player {
    constructor(x, y) {
      this.x = x;
      this.y = y;
      this.radius = 15;
      this.maxHp = 100;
      this.hp = 100;
      this.atk = 10;
      this.def = 5;
      this.speed = CONFIG.PLAYER_SPEED;
      this.invincible = 0;
    }

    update(dt) {
      if (this.invincible > 0) this.invincible -= dt;

      // ÁßªÂä®
      const moveX = game.joystick.dx * this.speed;
      const moveY = game.joystick.dy * this.speed;

      if (moveX !== 0 || moveY !== 0) {
        const newX = this.x + moveX;
        const newY = this.y + moveY;

        if (!isWall(newX, this.y, this.radius)) this.x = newX;
        if (!isWall(this.x, newY, this.radius)) this.y = newY;
      }

      // Ê£ÄÊü•Ê•ºÊ¢Ø
      const tileX = Math.floor(this.x / CONFIG.TILE_SIZE);
      const tileY = Math.floor(this.y / CONFIG.TILE_SIZE);
      if (game.map[tileY] && game.map[tileY][tileX] === TILE.STAIRS) {
        nextFloor();
      }
    }

    draw(ctx) {
      const screenX = this.x - game.camera.x;
      const screenY = this.y - game.camera.y;

      // Èó™ÁÉÅÊïàÊûú
      if (this.invincible > 0 && Math.floor(this.invincible / 100) % 2 === 0) {
        ctx.globalAlpha = 0.5;
      }

      // Ë∫´‰Ωì
      ctx.beginPath();
      ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = COLORS.PLAYER;
      ctx.fill();
      ctx.strokeStyle = COLORS.PLAYER_OUTLINE;
      ctx.lineWidth = 3;
      ctx.stroke();

      // ÁúºÁùõÊñπÂêë
      const eyeDir = game.joystick.dx !== 0 || game.joystick.dy !== 0
        ? { x: game.joystick.dx, y: game.joystick.dy }
        : { x: 0, y: -1 };
      const eyeX = screenX + eyeDir.x * 5;
      const eyeY = screenY + eyeDir.y * 5;

      ctx.beginPath();
      ctx.arc(eyeX - 4, eyeY - 2, 3, 0, Math.PI * 2);
      ctx.arc(eyeX + 4, eyeY - 2, 3, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();

      ctx.globalAlpha = 1;
    }

    takeDamage(dmg) {
      if (this.invincible > 0) return;

      const actualDmg = Math.max(1, dmg - this.def);
      this.hp -= actualDmg;
      this.invincible = 1000;

      showDamageNumber(this.x, this.y, actualDmg, '#ff6b6b');
      shakeScreen(5);

      if (this.hp <= 0) {
        this.hp = 0;
        endGame();
      }

      updateHUD();
    }
  }

  // ============ Êïå‰∫∫Á±ª ============
  class Enemy {
    constructor(x, y, type = 'normal') {
      this.x = x;
      this.y = y;
      this.radius = 12;
      this.type = type;

      const floorBonus = (game.floor - 1) * 0.2;

      if (type === 'elite') {
        this.maxHp = 50 * (1 + floorBonus);
        this.hp = this.maxHp;
        this.atk = 15 * (1 + floorBonus * 0.5);
        this.speed = CONFIG.ENEMY_SPEED * 0.8;
        this.radius = 18;
        this.color = '#9b59b6';
        this.outline = '#8e44ad';
      } else {
        this.maxHp = 20 * (1 + floorBonus);
        this.hp = this.maxHp;
        this.atk = 8 * (1 + floorBonus * 0.5);
        this.speed = CONFIG.ENEMY_SPEED;
        this.color = COLORS.ENEMY;
        this.outline = COLORS.ENEMY_OUTLINE;
      }

      this.attackCooldown = 0;
      this.knockback = { x: 0, y: 0 };
    }

    update(dt) {
      if (this.attackCooldown > 0) this.attackCooldown -= dt;

      // ÂáªÈÄÄ
      if (this.knockback.x !== 0 || this.knockback.y !== 0) {
        this.x += this.knockback.x;
        this.y += this.knockback.y;
        this.knockback.x *= 0.8;
        this.knockback.y *= 0.8;
        if (Math.abs(this.knockback.x) < 0.1) this.knockback.x = 0;
        if (Math.abs(this.knockback.y) < 0.1) this.knockback.y = 0;
        return;
      }

      // ËøΩË∏™Áé©ÂÆ∂
      const dx = game.player.x - this.x;
      const dy = game.player.y - this.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist > 30) {
        const moveX = (dx / dist) * this.speed;
        const moveY = (dy / dist) * this.speed;

        const newX = this.x + moveX;
        const newY = this.y + moveY;

        if (!isWall(newX, this.y, this.radius)) this.x = newX;
        if (!isWall(this.x, newY, this.radius)) this.y = newY;
      }

      // ÊîªÂáªÁé©ÂÆ∂
      if (dist < this.radius + game.player.radius + 5 && this.attackCooldown <= 0) {
        game.player.takeDamage(this.atk);
        this.attackCooldown = 1000;
      }
    }

    draw(ctx) {
      const screenX = this.x - game.camera.x;
      const screenY = this.y - game.camera.y;

      // Ë∫´‰Ωì
      ctx.beginPath();
      ctx.arc(screenX, screenY, this.radius, 0, Math.PI * 2);
      ctx.fillStyle = this.color;
      ctx.fill();
      ctx.strokeStyle = this.outline;
      ctx.lineWidth = 2;
      ctx.stroke();

      // ÁúºÁùõ
      const eyeDir = {
        x: (game.player.x - this.x) / (Math.sqrt((game.player.x - this.x) ** 2 + (game.player.y - this.y) ** 2) || 1),
        y: (game.player.y - this.y) / (Math.sqrt((game.player.x - this.x) ** 2 + (game.player.y - this.y) ** 2) || 1)
      };

      ctx.beginPath();
      ctx.arc(screenX + eyeDir.x * 4 - 3, screenY + eyeDir.y * 4, 2, 0, Math.PI * 2);
      ctx.arc(screenX + eyeDir.x * 4 + 3, screenY + eyeDir.y * 4, 2, 0, Math.PI * 2);
      ctx.fillStyle = '#fff';
      ctx.fill();

      // Ë°ÄÊù°
      const hpPercent = this.hp / this.maxHp;
      const barWidth = this.radius * 2;
      const barHeight = 4;
      const barX = screenX - barWidth / 2;
      const barY = screenY - this.radius - 10;

      ctx.fillStyle = COLORS.HEALTH_BG;
      ctx.fillRect(barX, barY, barWidth, barHeight);
      ctx.fillStyle = COLORS.HEALTH_FILL;
      ctx.fillRect(barX, barY, barWidth * hpPercent, barHeight);
    }

    takeDamage(dmg, knockbackDir) {
      this.hp -= dmg;
      showDamageNumber(this.x, this.y, dmg, '#ffdd59');

      if (knockbackDir) {
        this.knockback.x = knockbackDir.x * 8;
        this.knockback.y = knockbackDir.y * 8;
      }

      // Ê∑ªÂä†Á≤íÂ≠êÊïàÊûú
      for (let i = 0; i < 5; i++) {
        game.particles.push({
          x: this.x,
          y: this.y,
          vx: (Math.random() - 0.5) * 5,
          vy: (Math.random() - 0.5) * 5,
          life: 500,
          maxLife: 500,
          color: this.color,
          size: 4,
        });
      }

      if (this.hp <= 0) {
        return true; // Ê≠ª‰∫°
      }
      return false;
    }
  }

  // ============ Âú∞ÂõæÁîüÊàê ============
  function generateMap() {
    // ÂàùÂßãÂåñÂú∞Âõæ‰∏∫Â¢ô
    game.map = [];
    for (let y = 0; y < CONFIG.MAP_HEIGHT; y++) {
      game.map[y] = [];
      for (let x = 0; x < CONFIG.MAP_WIDTH; x++) {
        game.map[y][x] = TILE.WALL;
      }
    }

    game.rooms = [];

    // ÁîüÊàêÊàøÈó¥
    for (let i = 0; i < CONFIG.MAX_ROOMS; i++) {
      const w = randomInt(CONFIG.ROOM_MIN_SIZE, CONFIG.ROOM_MAX_SIZE);
      const h = randomInt(CONFIG.ROOM_MIN_SIZE, CONFIG.ROOM_MAX_SIZE);
      const x = randomInt(1, CONFIG.MAP_WIDTH - w - 1);
      const y = randomInt(1, CONFIG.MAP_HEIGHT - h - 1);

      const newRoom = { x, y, w, h, cx: Math.floor(x + w / 2), cy: Math.floor(y + h / 2) };

      let overlaps = false;
      for (const room of game.rooms) {
        if (roomsOverlap(newRoom, room)) {
          overlaps = true;
          break;
        }
      }

      if (!overlaps) {
        carveRoom(newRoom);

        if (game.rooms.length > 0) {
          const prevRoom = game.rooms[game.rooms.length - 1];
          if (Math.random() < 0.5) {
            carveHorizontalTunnel(prevRoom.cx, newRoom.cx, prevRoom.cy);
            carveVerticalTunnel(prevRoom.cy, newRoom.cy, newRoom.cx);
          } else {
            carveVerticalTunnel(prevRoom.cy, newRoom.cy, prevRoom.cx);
            carveHorizontalTunnel(prevRoom.cx, newRoom.cx, newRoom.cy);
          }
        }

        game.rooms.push(newRoom);
      }
    }

    // ÊîæÁΩÆÊ•ºÊ¢ØÂú®ÊúÄÂêé‰∏Ä‰∏™ÊàøÈó¥
    if (game.rooms.length > 1) {
      const lastRoom = game.rooms[game.rooms.length - 1];
      game.map[lastRoom.cy][lastRoom.cx] = TILE.STAIRS;
    }
  }

  function roomsOverlap(r1, r2) {
    return r1.x <= r2.x + r2.w + 1 && r1.x + r1.w + 1 >= r2.x &&
           r1.y <= r2.y + r2.h + 1 && r1.y + r1.h + 1 >= r2.y;
  }

  function carveRoom(room) {
    for (let y = room.y; y < room.y + room.h; y++) {
      for (let x = room.x; x < room.x + room.w; x++) {
        game.map[y][x] = TILE.FLOOR;
      }
    }
  }

  function carveHorizontalTunnel(x1, x2, y) {
    for (let x = Math.min(x1, x2); x <= Math.max(x1, x2); x++) {
      if (y >= 0 && y < CONFIG.MAP_HEIGHT && x >= 0 && x < CONFIG.MAP_WIDTH) {
        game.map[y][x] = TILE.FLOOR;
      }
    }
  }

  function carveVerticalTunnel(y1, y2, x) {
    for (let y = Math.min(y1, y2); y <= Math.max(y1, y2); y++) {
      if (y >= 0 && y < CONFIG.MAP_HEIGHT && x >= 0 && x < CONFIG.MAP_WIDTH) {
        game.map[y][x] = TILE.FLOOR;
      }
    }
  }

  function isWall(x, y, radius) {
    const tileX1 = Math.floor((x - radius) / CONFIG.TILE_SIZE);
    const tileX2 = Math.floor((x + radius) / CONFIG.TILE_SIZE);
    const tileY1 = Math.floor((y - radius) / CONFIG.TILE_SIZE);
    const tileY2 = Math.floor((y + radius) / CONFIG.TILE_SIZE);

    for (let ty = tileY1; ty <= tileY2; ty++) {
      for (let tx = tileX1; tx <= tileX2; tx++) {
        if (ty < 0 || ty >= CONFIG.MAP_HEIGHT || tx < 0 || tx >= CONFIG.MAP_WIDTH) {
          return true;
        }
        if (game.map[ty][tx] === TILE.WALL) {
          return true;
        }
      }
    }
    return false;
  }

  // ============ Êïå‰∫∫ÁîüÊàê ============
  function spawnEnemies() {
    game.enemies = [];

    const enemyCount = CONFIG.ENEMY_BASE_COUNT + Math.floor(game.floor * 1.5);

    for (let i = 0; i < enemyCount; i++) {
      // Ë∑≥ËøáÁ¨¨‰∏Ä‰∏™ÊàøÈó¥ÔºàÁé©ÂÆ∂Âá∫ÁîüÁÇπÔºâ
      const roomIdx = randomInt(1, game.rooms.length - 1);
      const room = game.rooms[roomIdx];

      if (!room) continue;

      const x = (room.x + randomInt(1, room.w - 2)) * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
      const y = (room.y + randomInt(1, room.h - 2)) * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

      const type = Math.random() < 0.15 + game.floor * 0.02 ? 'elite' : 'normal';
      game.enemies.push(new Enemy(x, y, type));
    }
  }

  // ============ ÊîªÂáªÁ≥ªÁªü ============
  function performAttack(direction) {
    const now = Date.now();
    if (now - game.attack.lastTime < CONFIG.ATTACK_COOLDOWN) return;
    game.attack.lastTime = now;

    let attackDir;

    if (direction) {
      // ÊñπÂêëÊîªÂáª
      attackDir = direction;
    } else {
      // Ëá™Âä®ÊîªÂáªÊúÄËøëÊïå‰∫∫
      let nearestEnemy = null;
      let nearestDist = Infinity;

      for (const enemy of game.enemies) {
        const dx = enemy.x - game.player.x;
        const dy = enemy.y - game.player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);

        if (dist < nearestDist && dist < CONFIG.ATTACK_RANGE * 2) {
          nearestDist = dist;
          nearestEnemy = enemy;
        }
      }

      if (nearestEnemy) {
        const dx = nearestEnemy.x - game.player.x;
        const dy = nearestEnemy.y - game.player.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        attackDir = { x: dx / dist, y: dy / dist };
      } else {
        // Ê≤°ÊúâÊïå‰∫∫Â∞±ÊúùÈù¢ÂêëÊñπÂêë
        attackDir = game.joystick.dx !== 0 || game.joystick.dy !== 0
          ? { x: game.joystick.dx, y: game.joystick.dy }
          : { x: 0, y: -1 };
      }
    }

    // ÂàõÂª∫ÊîªÂáªÊïàÊûú
    game.particles.push({
      type: 'attack',
      x: game.player.x + attackDir.x * 30,
      y: game.player.y + attackDir.y * 30,
      dir: attackDir,
      life: 200,
      maxLife: 200,
    });

    // Ê£ÄÊµãÊîªÂáªÂëΩ‰∏≠
    const attackX = game.player.x + attackDir.x * 30;
    const attackY = game.player.y + attackDir.y * 30;

    for (let i = game.enemies.length - 1; i >= 0; i--) {
      const enemy = game.enemies[i];
      const dx = enemy.x - attackX;
      const dy = enemy.y - attackY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist < CONFIG.ATTACK_RANGE) {
        const dead = enemy.takeDamage(game.player.atk, attackDir);
        if (dead) {
          game.enemies.splice(i, 1);
          game.kills++;
          updateHUD();

          // ÂáªÊùÄÁ≤íÂ≠êÊïàÊûú
          for (let j = 0; j < 10; j++) {
            game.particles.push({
              x: enemy.x,
              y: enemy.y,
              vx: (Math.random() - 0.5) * 8,
              vy: (Math.random() - 0.5) * 8,
              life: 800,
              maxLife: 800,
              color: enemy.color,
              size: 6,
            });
          }
        }
      }
    }
  }

  // ============ ‰∏ã‰∏ÄÂ±Ç ============
  function nextFloor() {
    game.floor++;

    // ÊòæÁ§∫Â±ÇÁ∫ßÊèêÁ§∫
    const indicator = document.getElementById('levelIndicator');
    indicator.textContent = `Á¨¨ ${game.floor} Â±Ç`;
    indicator.classList.add('show');
    setTimeout(() => indicator.classList.remove('show'), 2000);

    // Áé©ÂÆ∂Â±ûÊÄßÊèêÂçá
    game.player.atk += 2;
    game.player.def += 1;
    game.player.maxHp += 10;
    game.player.hp = Math.min(game.player.hp + 30, game.player.maxHp);

    // ÁîüÊàêÊñ∞Âú∞Âõæ
    generateMap();
    spawnEnemies();

    // Áé©ÂÆ∂ÊîæÂà∞Á¨¨‰∏Ä‰∏™ÊàøÈó¥
    const startRoom = game.rooms[0];
    game.player.x = startRoom.cx * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;
    game.player.y = startRoom.cy * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2;

    updateHUD();
    updateMinimap();
  }

  // ============ Ê∏∏ÊàèÁªìÊùü ============
  function endGame() {
    game.gameOver = true;

    document.getElementById('finalFloor').textContent = game.floor;
    document.getElementById('finalKills').textContent = game.kills;
    document.getElementById('gameOver').style.display = 'flex';
  }

  function restartGame() {
    game.gameOver = false;
    game.floor = 1;
    game.kills = 0;
    game.enemies = [];
    game.particles = [];

    document.getElementById('gameOver').style.display = 'none';

    generateMap();

    const startRoom = game.rooms[0];
    game.player = new Player(
      startRoom.cx * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,
      startRoom.cy * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2
    );

    spawnEnemies();
    updateHUD();
    updateMinimap();

    // ÊòæÁ§∫Â±ÇÁ∫ßÊèêÁ§∫
    const indicator = document.getElementById('levelIndicator');
    indicator.textContent = `Á¨¨ 1 Â±Ç`;
    indicator.classList.add('show');
    setTimeout(() => indicator.classList.remove('show'), 2000);
  }

  // ============ UIÊõ¥Êñ∞ ============
  function updateHUD() {
    const hpPercent = (game.player.hp / game.player.maxHp) * 100;
    document.getElementById('healthFill').style.width = hpPercent + '%';
    document.getElementById('atkStat').textContent = Math.floor(game.player.atk);
    document.getElementById('defStat').textContent = Math.floor(game.player.def);
    document.getElementById('floorStat').textContent = game.floor;
    document.getElementById('killStat').textContent = game.kills;
  }

  function updateMinimap() {
    const ctx = game.minimapCtx;
    const scale = 4;

    ctx.fillStyle = '#111';
    ctx.fillRect(0, 0, 120, 120);

    const offsetX = 60 - (game.player.x / CONFIG.TILE_SIZE) * scale;
    const offsetY = 60 - (game.player.y / CONFIG.TILE_SIZE) * scale;

    for (let y = 0; y < CONFIG.MAP_HEIGHT; y++) {
      for (let x = 0; x < CONFIG.MAP_WIDTH; x++) {
        const tile = game.map[y][x];
        const px = x * scale + offsetX;
        const py = y * scale + offsetY;

        if (px < -scale || px > 120 || py < -scale || py > 120) continue;

        if (tile === TILE.FLOOR) {
          ctx.fillStyle = '#555';
          ctx.fillRect(px, py, scale, scale);
        } else if (tile === TILE.STAIRS) {
          ctx.fillStyle = '#f1c40f';
          ctx.fillRect(px, py, scale, scale);
        }
      }
    }

    // Êïå‰∫∫ÁÇπ
    ctx.fillStyle = '#e74c3c';
    for (const enemy of game.enemies) {
      const px = (enemy.x / CONFIG.TILE_SIZE) * scale + offsetX;
      const py = (enemy.y / CONFIG.TILE_SIZE) * scale + offsetY;
      ctx.beginPath();
      ctx.arc(px, py, 2, 0, Math.PI * 2);
      ctx.fill();
    }

    // Áé©ÂÆ∂ÁÇπ
    ctx.fillStyle = '#3498db';
    ctx.beginPath();
    ctx.arc(60, 60, 4, 0, Math.PI * 2);
    ctx.fill();
  }

  let screenShake = 0;
  function shakeScreen(intensity) {
    screenShake = intensity;
  }

  function showDamageNumber(x, y, dmg, color) {
    const elem = document.createElement('div');
    elem.className = 'damage-number';
    elem.textContent = '-' + Math.floor(dmg);
    elem.style.color = color;
    elem.style.left = (x - game.camera.x + game.width / 2) + 'px';
    elem.style.top = (y - game.camera.y + game.height / 2) + 'px';
    document.body.appendChild(elem);

    setTimeout(() => elem.remove(), 1000);
  }

  // ============ Ê∏≤Êüì ============
  function render() {
    const ctx = game.ctx;

    // Ê∏ÖÂ±è
    ctx.fillStyle = '#1a1a2e';
    ctx.fillRect(0, 0, game.width, game.height);

    // Áõ∏Êú∫Ë∑üÈöè
    game.camera.x = game.player.x - game.width / 2;
    game.camera.y = game.player.y - game.height / 2;

    // Â±èÂπïÈúáÂä®
    if (screenShake > 0) {
      game.camera.x += (Math.random() - 0.5) * screenShake * 2;
      game.camera.y += (Math.random() - 0.5) * screenShake * 2;
      screenShake *= 0.9;
      if (screenShake < 0.5) screenShake = 0;
    }

    // ËÆ°ÁÆóÂèØËßÅËåÉÂõ¥
    const startTileX = Math.max(0, Math.floor(game.camera.x / CONFIG.TILE_SIZE) - 1);
    const startTileY = Math.max(0, Math.floor(game.camera.y / CONFIG.TILE_SIZE) - 1);
    const endTileX = Math.min(CONFIG.MAP_WIDTH, Math.ceil((game.camera.x + game.width) / CONFIG.TILE_SIZE) + 1);
    const endTileY = Math.min(CONFIG.MAP_HEIGHT, Math.ceil((game.camera.y + game.height) / CONFIG.TILE_SIZE) + 1);

    // ÁªòÂà∂Âú∞Âõæ
    for (let y = startTileY; y < endTileY; y++) {
      for (let x = startTileX; x < endTileX; x++) {
        const tile = game.map[y][x];
        const screenX = x * CONFIG.TILE_SIZE - game.camera.x;
        const screenY = y * CONFIG.TILE_SIZE - game.camera.y;

        if (tile === TILE.WALL) {
          // Â¢ô‰ΩìÈ°∂ÈÉ®
          ctx.fillStyle = COLORS.WALL_TOP;
          ctx.fillRect(screenX, screenY, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE * 0.3);
          // Â¢ô‰Ωì
          ctx.fillStyle = COLORS.WALL;
          ctx.fillRect(screenX, screenY + CONFIG.TILE_SIZE * 0.3, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE * 0.7);
        } else if (tile === TILE.FLOOR) {
          ctx.fillStyle = (x + y) % 2 === 0 ? COLORS.FLOOR : COLORS.FLOOR_ALT;
          ctx.fillRect(screenX, screenY, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);
        } else if (tile === TILE.STAIRS) {
          ctx.fillStyle = COLORS.FLOOR;
          ctx.fillRect(screenX, screenY, CONFIG.TILE_SIZE, CONFIG.TILE_SIZE);

          // Ê•ºÊ¢ØÂõæÊ†á
          ctx.fillStyle = COLORS.STAIRS;
          ctx.font = '24px sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('‚¨á', screenX + CONFIG.TILE_SIZE / 2, screenY + CONFIG.TILE_SIZE / 2);
        }
      }
    }

    // ÁªòÂà∂Êïå‰∫∫
    for (const enemy of game.enemies) {
      enemy.draw(ctx);
    }

    // ÁªòÂà∂Áé©ÂÆ∂
    game.player.draw(ctx);

    // ÁªòÂà∂Á≤íÂ≠ê
    for (let i = game.particles.length - 1; i >= 0; i--) {
      const p = game.particles[i];

      if (p.type === 'attack') {
        const screenX = p.x - game.camera.x;
        const screenY = p.y - game.camera.y;
        const alpha = p.life / p.maxLife;
        const size = 40 * (1 - alpha * 0.5);

        ctx.save();
        ctx.globalAlpha = alpha * 0.8;
        ctx.fillStyle = COLORS.ATTACK;
        ctx.beginPath();
        ctx.arc(screenX, screenY, size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      } else {
        const screenX = p.x - game.camera.x;
        const screenY = p.y - game.camera.y;
        const alpha = p.life / p.maxLife;

        ctx.globalAlpha = alpha;
        ctx.fillStyle = p.color;
        ctx.beginPath();
        ctx.arc(screenX, screenY, p.size * alpha, 0, Math.PI * 2);
        ctx.fill();
        ctx.globalAlpha = 1;
      }
    }
  }

  // ============ Ê∏∏ÊàèÂæ™ÁéØ ============
  function gameLoop(timestamp) {
    if (!game.lastTime) game.lastTime = timestamp;
    const dt = timestamp - game.lastTime;
    game.lastTime = timestamp;

    if (!game.gameOver) {
      // Êõ¥Êñ∞
      game.player.update(dt);

      for (const enemy of game.enemies) {
        enemy.update(dt);
      }

      // Êõ¥Êñ∞Á≤íÂ≠ê
      for (let i = game.particles.length - 1; i >= 0; i--) {
        const p = game.particles[i];
        p.life -= dt;
        if (p.vx) p.x += p.vx;
        if (p.vy) p.y += p.vy;
        if (p.life <= 0) {
          game.particles.splice(i, 1);
        }
      }

      // Ëá™Âä®ÊîªÂáª
      if (game.attack.isHolding && !game.attack.direction) {
        const now = Date.now();
        if (now - game.attack.holdStartTime > 200) {
          performAttack(null);
        }
      }

      // Êõ¥Êñ∞Â∞èÂú∞Âõæ
      updateMinimap();
    }

    render();
    requestAnimationFrame(gameLoop);
  }

  // ============ ËæìÂÖ•Â§ÑÁêÜ ============
  function setupInput() {
    const joystickArea = document.getElementById('joystickArea');
    const joystickKnob = document.getElementById('joystickKnob');
    const attackBtn = document.getElementById('attackBtn');

    let joystickTouch = null;
    let attackTouch = null;

    // ÊëáÊùÜ
    function handleJoystickStart(e) {
      e.preventDefault();
      const touch = e.changedTouches ? e.changedTouches[0] : e;
      joystickTouch = touch.identifier !== undefined ? touch.identifier : 'mouse';
      game.joystick.active = true;
    }

    function handleJoystickMove(e) {
      if (!game.joystick.active) return;
      e.preventDefault();

      let touch;
      if (e.changedTouches) {
        for (const t of e.changedTouches) {
          if (t.identifier === joystickTouch) {
            touch = t;
            break;
          }
        }
        if (!touch) return;
      } else {
        touch = e;
      }

      const rect = joystickArea.getBoundingClientRect();
      const centerX = rect.left + rect.width / 2;
      const centerY = rect.top + rect.height / 2;

      let dx = touch.clientX - centerX;
      let dy = touch.clientY - centerY;
      const dist = Math.sqrt(dx * dx + dy * dy);
      const maxDist = rect.width / 2 - 25;

      if (dist > maxDist) {
        dx = (dx / dist) * maxDist;
        dy = (dy / dist) * maxDist;
      }

      joystickKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;

      const normalizedDist = Math.min(dist, maxDist) / maxDist;
      game.joystick.dx = (dx / maxDist) * normalizedDist;
      game.joystick.dy = (dy / maxDist) * normalizedDist;
    }

    function handleJoystickEnd(e) {
      if (e.changedTouches) {
        let found = false;
        for (const t of e.changedTouches) {
          if (t.identifier === joystickTouch) {
            found = true;
            break;
          }
        }
        if (!found) return;
      }

      game.joystick.active = false;
      game.joystick.dx = 0;
      game.joystick.dy = 0;
      joystickKnob.style.transform = 'translate(-50%, -50%)';
      joystickTouch = null;
    }

    joystickArea.addEventListener('mousedown', handleJoystickStart);
    joystickArea.addEventListener('touchstart', handleJoystickStart, { passive: false });
    window.addEventListener('mousemove', handleJoystickMove);
    window.addEventListener('touchmove', handleJoystickMove, { passive: false });
    window.addEventListener('mouseup', handleJoystickEnd);
    window.addEventListener('touchend', handleJoystickEnd);

    // ÊîªÂáªÊåâÈíÆ
    function handleAttackStart(e) {
      e.preventDefault();
      const touch = e.changedTouches ? e.changedTouches[0] : e;
      attackTouch = touch.identifier !== undefined ? touch.identifier : 'mouse';

      game.attack.isHolding = true;
      game.attack.holdStartTime = Date.now();
      game.attack.dragStart = { x: touch.clientX, y: touch.clientY };
      game.attack.direction = null;

      attackBtn.classList.add('active');
    }

    function handleAttackMove(e) {
      if (!game.attack.isHolding) return;

      let touch;
      if (e.changedTouches) {
        for (const t of e.changedTouches) {
          if (t.identifier === attackTouch) {
            touch = t;
            break;
          }
        }
        if (!touch) return;
      } else {
        touch = e;
      }

      const dx = touch.clientX - game.attack.dragStart.x;
      const dy = touch.clientY - game.attack.dragStart.y;
      const dist = Math.sqrt(dx * dx + dy * dy);

      if (dist > 30) {
        attackBtn.classList.add('dragging');
        game.attack.direction = { x: dx / dist, y: dy / dist };
      } else {
        attackBtn.classList.remove('dragging');
        game.attack.direction = null;
      }
    }

    function handleAttackEnd(e) {
      if (e.changedTouches) {
        let found = false;
        for (const t of e.changedTouches) {
          if (t.identifier === attackTouch) {
            found = true;
            break;
          }
        }
        if (!found) return;
      }

      if (game.attack.isHolding) {
        // Â¶ÇÊûúÊúâÊãñÂä®ÊñπÂêëÂ∞±ÊåâÊñπÂêëÊîªÂáªÔºåÂê¶ÂàôËá™Âä®ÊîªÂáª
        if (game.attack.direction) {
          performAttack(game.attack.direction);
        } else {
          performAttack(null);
        }
      }

      game.attack.isHolding = false;
      game.attack.direction = null;
      attackBtn.classList.remove('active', 'dragging');
      attackTouch = null;
    }

    attackBtn.addEventListener('mousedown', handleAttackStart);
    attackBtn.addEventListener('touchstart', handleAttackStart, { passive: false });
    window.addEventListener('mousemove', handleAttackMove);
    window.addEventListener('touchmove', handleAttackMove, { passive: false });
    window.addEventListener('mouseup', handleAttackEnd);
    window.addEventListener('touchend', handleAttackEnd);

    // ÈáçÊñ∞ÂºÄÂßãÊåâÈíÆ
    document.getElementById('restartBtn').addEventListener('click', restartGame);

    // ÈîÆÁõòÊéßÂà∂
    const keys = {};
    window.addEventListener('keydown', e => {
      keys[e.code] = true;
      updateKeyboardMovement();

      if (e.code === 'Space' || e.code === 'KeyJ') {
        performAttack(null);
      }
    });
    window.addEventListener('keyup', e => {
      keys[e.code] = false;
      updateKeyboardMovement();
    });

    function updateKeyboardMovement() {
      let dx = 0, dy = 0;
      if (keys['ArrowUp'] || keys['KeyW']) dy -= 1;
      if (keys['ArrowDown'] || keys['KeyS']) dy += 1;
      if (keys['ArrowLeft'] || keys['KeyA']) dx -= 1;
      if (keys['ArrowRight'] || keys['KeyD']) dx += 1;

      if (dx !== 0 || dy !== 0) {
        const len = Math.sqrt(dx * dx + dy * dy);
        game.joystick.dx = dx / len;
        game.joystick.dy = dy / len;
      } else if (!game.joystick.active) {
        game.joystick.dx = 0;
        game.joystick.dy = 0;
      }
    }
  }

  // ============ Â∑•ÂÖ∑ÂáΩÊï∞ ============
  function randomInt(min, max) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
  }

  // ============ ÂàùÂßãÂåñ ============
  function init() {
    game.canvas = document.getElementById('gameCanvas');
    game.ctx = game.canvas.getContext('2d');
    game.minimapCanvas = document.getElementById('minimapCanvas');
    game.minimapCtx = game.minimapCanvas.getContext('2d');

    function resize() {
      game.dpr = Math.min(2, window.devicePixelRatio || 1);
      game.width = window.innerWidth;
      game.height = window.innerHeight;

      game.canvas.width = game.width * game.dpr;
      game.canvas.height = game.height * game.dpr;
      game.canvas.style.width = game.width + 'px';
      game.canvas.style.height = game.height + 'px';
      game.ctx.scale(game.dpr, game.dpr);

      game.minimapCanvas.width = 120 * game.dpr;
      game.minimapCanvas.height = 120 * game.dpr;
      game.minimapCtx.scale(game.dpr, game.dpr);
    }

    window.addEventListener('resize', resize);
    resize();

    generateMap();

    const startRoom = game.rooms[0];
    game.player = new Player(
      startRoom.cx * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2,
      startRoom.cy * CONFIG.TILE_SIZE + CONFIG.TILE_SIZE / 2
    );

    spawnEnemies();
    setupInput();
    updateHUD();
    updateMinimap();

    // ÊòæÁ§∫Â±ÇÁ∫ßÊèêÁ§∫
    const indicator = document.getElementById('levelIndicator');
    indicator.classList.add('show');
    setTimeout(() => indicator.classList.remove('show'), 2000);

    requestAnimationFrame(gameLoop);
  }

  init();
})();
</script>
</body>
</html>
