<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>先天八卦 / 64卦：tesseract 卦网</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#eef2f7; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }

    #hud{
      position:fixed; left:10px; top:10px; z-index:10;
      background:rgba(0,0,0,.56); color:#fff;
      padding:10px 12px; border-radius:14px;
      font:14px/1.35 system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
      max-width:min(520px, calc(100vw - 20px));
      backdrop-filter: blur(6px);
    }
    #hudHeader{
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    #hudTitle{ font-weight:900; }
    #hudBody{ margin-top:8px; }

    #hud.collapsed{
      padding:8px 10px;
      max-width:min(260px, calc(100vw - 20px));
    }
    #hud.collapsed #hudBody{ display:none; }

    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:8px; }
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:2px 8px; border-radius:999px; background:rgba(255,255,255,.12);
    }
    .sw{ width:14px; height:14px; border-radius:4px; display:inline-block; border:1px solid rgba(255,255,255,.35); }

    button{
      appearance:none; border:1px solid rgba(255,255,255,.25);
      background:rgba(255,255,255,.10);
      color:#fff; border-radius:10px;
      padding:6px 10px; cursor:pointer;
      font:inherit;
    }
    button.active{ background:rgba(255,255,255,.22); border-color:rgba(255,255,255,.45); }
    button:active{ transform:translateY(1px); }
    .mini{ padding:4px 8px; border-radius:999px; }
    .sep{ width:1px; height:22px; background:rgba(255,255,255,.2); }

    label{ display:inline-flex; align-items:center; gap:6px; }
    input[type="checkbox"]{ width:16px; height:16px; }
    input[type="range"]{ width:min(260px, 62vw); }
    .hint{ opacity:.85; font-size:12px; margin-top:8px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    #mirrorPanel, #hexPanel{
      margin-top:10px; padding-top:10px;
      border-top:1px solid rgba(255,255,255,.18);
    }
    #mirrorPanel{ display:none; }
    #hexPanel{ display:none; }

    #check{ margin-top:8px; opacity:.95; }
    #detail{ margin-top:8px; opacity:.98; }
    #detail b{ font-weight:900; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div id="hud">
  <div id="hudHeader">
    <div id="hudTitle">bit 立方体：8卦 / 64卦（卦网）</div>
    <button id="btnHudToggle" class="mini">☰</button>
  </div>

  <div id="hudBody">
    <div class="row">
      <span class="chip"><span class="sw" style="background:#cfd6df;"></span>浅色=阳爻(0)</span>
      <span class="chip"><span class="sw" style="background:#1f2329;"></span>深色=阴爻(1)</span>
      <span class="chip"><span class="sw" style="background:#ffd24a;"></span>黄点=本我(下卦)</span>
      <span class="chip"><span class="sw" style="background:#5ad6ff;"></span>蓝点=真我(上卦)</span>
    </div>

    <div class="row">
      <button id="btnMode8">8卦</button>
      <button id="btnMode64" class="active">64卦</button>
      <span class="sep"></span>
      <button id="btnOrtho" class="active">正交</button>
      <button id="btnPersp">透视</button>
      <button id="btnSnap" class="mini">乾坤重合(六边形)</button>
      <button id="btnReset" class="mini">重置</button>
    </div>

    <div class="hint">交互：拖拽旋转｜滚轮/双指缩放｜点顶点查看该点的 8 条组合（=叠加态）</div>

    <div id="mirrorPanel">
      <div style="font-weight:900; margin-bottom:6px;">镜像立方体（按面生成）</div>
      <div class="row">
        <label><input id="mxp" type="checkbox">+X</label>
        <label><input id="mxn" type="checkbox">-X</label>
        <label><input id="myp" type="checkbox">+Y</label>
        <label><input id="myn" type="checkbox">-Y</label>
        <label><input id="mzp" type="checkbox">+Z</label>
        <label><input id="mzn" type="checkbox">-Z</label>
      </div>
      <div class="hint">8卦模式：勾选后以该面四顶点为共享面生成镜像 cube。</div>
    </div>

    <div id="hexPanel">
      <div style="font-weight:900; margin-bottom:6px;">64卦（本我×真我 卦网）</div>
      <div class="row">
        <label><input id="showHexNet" type="checkbox" checked>显示64卦虚线卦网(默认)</label>
        <label><input id="showStructure" type="checkbox">显示结构棱(阴阳边+8条w)</label>
      </div>
      <div class="row">
        <label><input id="hideYellow" type="checkbox" checked>隐藏黄色卦象(默认)</label>
        <label><input id="showLabels64" type="checkbox">显示顶点卦名/bit</label>
      </div>
      <div class="row">
        <label><input id="auto4d" type="checkbox">自动四维旋转(可选)</label>
      </div>
      <div class="hint">
        默认只显示“64条虚线卦网”。<br>
        你给的空间关系：顶面(011 001 010 000)，底面(111 101 100 110) —— 本质是 y-bit 分面；本视角沿体对角线让 000 与 111 投影重合形成正六边形。
      </div>
    </div>

    <div id="check"></div>
    <div id="detail"></div>
  </div>
</div>

<script>
(() => {
  // ====== 先天序：乾兑离震巽坎艮坤 = 000..111 ======
  // 顶点卦bits约定：X向边=初爻、Y向边=二爻、Z向边=三爻，边值 0阳 1阴
  // 采用可解规则：X边值=yBit，Y边值=zBit，Z边值=xBit
  // 所以 顶点bits = (y,z,x) => `${y}${z}${x}`
  const bitsToName = {
    "000":"乾","001":"兑","010":"离","011":"震",
    "100":"巽","101":"坎","110":"艮","111":"坤"
  };

  // ====== 颜色 ======
  const COLOR_YANG = "#cfd6df";
  const COLOR_YIN  = "#1f2329";
  const COLOR_NODE = "#0b0f14";
  const COLOR_LABEL = "#0b0f14";
  const COLOR_HI = "#ffb020";

  const COLOR_REAL = "#ffd24a"; // 黄
  const COLOR_TRUE = "#5ad6ff"; // 蓝
  const COLOR_NEUTRAL = "rgba(20,25,30,.55)"; // 隐藏黄时的“占位点”
  const COLOR_NET = "rgba(30,40,55,.22)";
  const COLOR_WLINK = "rgba(40,50,60,.35)";

  // ====== DOM ======
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const hud = document.getElementById("hud");
  const btnHudToggle = document.getElementById("btnHudToggle");

  const btnMode8  = document.getElementById("btnMode8");
  const btnMode64 = document.getElementById("btnMode64");
  const btnOrtho  = document.getElementById("btnOrtho");
  const btnPersp  = document.getElementById("btnPersp");
  const btnSnap   = document.getElementById("btnSnap");
  const btnReset  = document.getElementById("btnReset");

  const mirrorPanel = document.getElementById("mirrorPanel");
  const hexPanel    = document.getElementById("hexPanel");

  const mxp = document.getElementById("mxp");
  const mxn = document.getElementById("mxn");
  const myp = document.getElementById("myp");
  const myn = document.getElementById("myn");
  const mzp = document.getElementById("mzp");
  const mzn = document.getElementById("mzn");

  const showHexNetEl   = document.getElementById("showHexNet");
  const showStructureEl= document.getElementById("showStructure");
  const hideYellowEl   = document.getElementById("hideYellow");
  const showLabels64El = document.getElementById("showLabels64");
  const auto4dEl       = document.getElementById("auto4d");

  const hudCheck  = document.getElementById("check");
  const hudDetail = document.getElementById("detail");

  // ====== 视图 ======
  let W=0, H=0, DPR=1;
  let mode = "hex64";     // 默认：64卦
  let projMode = "ortho"; // 默认：正交（保证六边形）
  let rotX = 0;
  let rotY = 0;
  let zoom = 1.05;

  // ====== 场景 ======
  let vertices = [];
  let edges = [];
  let vByKey = new Map();
  let sceneMaxAbs = 3.2;

  let selKey = null;

  // ====== 4D旋转 ======
  const W_DIST = 4.0;
  let aXW=0, aYW=0, aYZ=0;
  let lastTs=null;

  // ====== util ======
  const STEP = 2;
  function invertBits3(bits){ return bits.replace(/[01]/g, c => c==="0"?"1":"0"); }
  function xorBits3(a,b){
    let out="";
    for (let i=0;i<3;i++) out += (a[i]===b[i] ? "0":"1");
    return out;
  }
  function keyOf(cubeId, x,y,z){ return `${cubeId}|${x},${y},${z}`; }
  function bitsFromLocal(x,y,z){ return `${y}${z}${x}`; }
  function trigramIndex(bits){ return (parseInt(bits,2)&7)+1; }

  // 8卦世界坐标
  function makeCubeInstance({id, axisBase={x:-1,y:-1,z:-1}, axisMirror={x:false,y:false,z:false}, showLabels=true, pickable=true}) {
    return { id, showLabels, pickable, ax: {x:{base:axisBase.x,mirror:!!axisMirror.x}, y:{base:axisBase.y,mirror:!!axisMirror.y}, z:{base:axisBase.z,mirror:!!axisMirror.z}} };
  }
  function worldPos(cube, xBit,yBit,zBit){
    const bx = cube.ax.x.mirror ? (1-xBit) : xBit;
    const by = cube.ax.y.mirror ? (1-yBit) : yBit;
    const bz = cube.ax.z.mirror ? (1-zBit) : zBit;
    return {
      x: cube.ax.x.base + STEP*bx,
      y: cube.ax.y.base + STEP*by,
      z: cube.ax.z.base + STEP*bz
    };
  }

  // ====== 默认视角：乾(000)与坤(111)重叠 → 正六边形 ======
  // 你想要的“六边形对角视图”
  function snapHexView(){
    // yaw = -45°, pitch = arctan(1/sqrt(2))
    rotY = -Math.PI/4;
    rotX = Math.atan(1/Math.sqrt(2));
  }
  function resetView(){
    projMode = "ortho";
    btnOrtho.classList.add("active");
    btnPersp.classList.remove("active");
    zoom = (mode==="hex64") ? 1.05 : 1.12;
    snapHexView();
    updateHUD();
  }

  // ====== buildScene ======
  function buildScene(){
    selKey = null;
    vertices = [];
    edges = [];

    if (mode === "bagua"){
      mirrorPanel.style.display = "block";
      hexPanel.style.display = "none";

      const cubes = [];
      const base = makeCubeInstance({ id:"B", showLabels:true, pickable:true });
      cubes.push(base);

      const wantMirrors = [
        {on: mxp.checked, id:"Mx+", axis:"x", base:  1, mirror:true},
        {on: mxn.checked, id:"Mx-", axis:"x", base: -3, mirror:true},
        {on: myp.checked, id:"My+", axis:"y", base:  1, mirror:true},
        {on: myn.checked, id:"My-", axis:"y", base: -3, mirror:true},
        {on: mzp.checked, id:"Mz+", axis:"z", base:  1, mirror:true},
        {on: mzn.checked, id:"Mz-", axis:"z", base: -3, mirror:true},
      ];

      for (const m of wantMirrors){
        if (!m.on) continue;
        const axisBase = {x:-1,y:-1,z:-1};
        const axisMirror = {x:false,y:false,z:false};
        axisBase[m.axis] = m.base;
        axisMirror[m.axis] = true;
        cubes.push(makeCubeInstance({ id:m.id, axisBase, axisMirror, showLabels:false, pickable:false }));
      }

      for (const cube of cubes){
        for (let x=0;x<=1;x++) for (let y=0;y<=1;y++) for (let z=0;z<=1;z++){
          const bits = bitsFromLocal(x,y,z);
          const key = keyOf(cube.id,x,y,z);
          vertices.push({
            key, mode:"bagua",
            role:"bagua",
            pickable:cube.pickable,
            showLabel:cube.showLabels,
            bits, name:bitsToName[bits],
            local:{x,y,z},
            world: worldPos(cube,x,y,z)
          });
        }
        // edges
        for (let y=0;y<=1;y++) for (let z=0;z<=1;z++){
          edges.push({type:"edge", val:y, a:keyOf(cube.id,0,y,z), b:keyOf(cube.id,1,y,z)});
        }
        for (let x=0;x<=1;x++) for (let z=0;z<=1;z++){
          edges.push({type:"edge", val:z, a:keyOf(cube.id,x,0,z), b:keyOf(cube.id,x,1,z)});
        }
        for (let x=0;x<=1;x++) for (let y=0;y<=1;y++){
          edges.push({type:"edge", val:x, a:keyOf(cube.id,x,y,0), b:keyOf(cube.id,x,y,1)});
        }
      }

      sceneMaxAbs = 1;
      vByKey = new Map(vertices.map(v => [v.key,v]));
      for (const v of vertices){
        sceneMaxAbs = Math.max(sceneMaxAbs, Math.abs(v.world.x), Math.abs(v.world.y), Math.abs(v.world.z));
      }

    } else {
      mirrorPanel.style.display = "none";
      hexPanel.style.display = "block";

      // 64模式：两层立方体（real/true）用于4D投影
      // 真实层：bits=L=yzx
      // 真我层：bits=~(yzx)（全反）
      const roles = [
        {role:"real", w:+1},
        {role:"true", w:-1},
      ];

      for (const R of roles){
        for (let x=0;x<=1;x++) for (let y=0;y<=1;y++) for (let z=0;z<=1;z++){
          const coordBits = bitsFromLocal(x,y,z);
          const bits = (R.role==="real") ? coordBits : invertBits3(coordBits);
          const key = `${R.role}|${x},${y},${z}`;

          const base4 = {
            x: x? +1:-1,
            y: y? +1:-1,
            z: z? +1:-1,
            w: R.w
          };

          vertices.push({
            key, mode:"hex64",
            role:R.role,
            pickable:true,
            showLabel:true,
            local:{x,y,z},
            bits, name:bitsToName[bits],
            coordBits,
            base4
          });
        }
      }

      vByKey = new Map(vertices.map(v=>[v.key,v]));
      sceneMaxAbs = 3.2;

      // 结构棱（各层12条）+ w连接（8条）
      function addStructure(role){
        // X向：val=y
        for (let y=0;y<=1;y++) for (let z=0;z<=1;z++){
          edges.push({type:"edge64", role, val:y, a:`${role}|0,${y},${z}`, b:`${role}|1,${y},${z}`});
        }
        // Y向：val=z
        for (let x=0;x<=1;x++) for (let z=0;z<=1;z++){
          edges.push({type:"edge64", role, val:z, a:`${role}|${x},0,${z}`, b:`${role}|${x},1,${z}`});
        }
        // Z向：val=x
        for (let x=0;x<=1;x++) for (let y=0;y<=1;y++){
          edges.push({type:"edge64", role, val:x, a:`${role}|${x},${y},0`, b:`${role}|${x},${y},1`});
        }
      }
      addStructure("real");
      addStructure("true");

      for (let x=0;x<=1;x++) for (let y=0;y<=1;y++) for (let z=0;z<=1;z++){
        edges.push({type:"wlink", a:`real|${x},${y},${z}`, b:`true|${x},${y},${z}`});
      }

      // 64卦卦网：对每个 real(L) 与 true(U) 都连一条虚线
      // 同时计算该线对应的“宫mask”：mask = U XOR ~L
      const realVs = vertices.filter(v=>v.role==="real");
      const trueVs = vertices.filter(v=>v.role==="true").slice().sort((a,b)=>a.bits.localeCompare(b.bits));
      for (const rv of realVs){
        const L = rv.bits;
        const invL = invertBits3(L);
        for (const tv of trueVs){
          const U = tv.bits;
          const mask = xorBits3(U, invL);      // 000..111
          const palace = bitsToName[mask];     // 乾兑离震巽坎艮坤
          const hexBits = `${U}${L}`;
          const hexNum = (parseInt(hexBits,2) & 63) + 1; // 二进制1..64
          edges.push({
            type:"hex",
            a: rv.key,
            b: tv.key,
            mask, palace,
            hexBits, hexNum
          });
        }
      }
    }

    updateHUD();
  }

  // ====== HUD texts ======
  function updateHUD(){
    btnMode8.classList.toggle("active", mode==="bagua");
    btnMode64.classList.toggle("active", mode==="hex64");
    btnOrtho.classList.toggle("active", projMode==="ortho");
    btnPersp.classList.toggle("active", projMode==="persp");

    if (mode==="bagua"){
      let yang=0, yin=0;
      for (const e of edges){
        if (e.type!=="edge") continue;
        e.val===0? yang++ : yin++;
      }
      hudCheck.innerHTML = `模式：<b>8卦</b> ｜ 投影：<b>${projMode==="ortho"?"正交":"透视"}</b><br>`+
                           `校验(本卦B)：阳6 阴6（镜像不参与校验显示）`;
    } else {
      const showHexNet = !!showHexNetEl.checked;
      const showStructure = !!showStructureEl.checked;
      const hideYellow = !!hideYellowEl.checked;
      const showLabels = !!showLabels64El.checked;
      const auto4d = !!auto4dEl.checked;
      hudCheck.innerHTML =
        `模式：<b>64卦</b> ｜ 投影：<b>${projMode==="ortho"?"正交":"透视"}</b><br>`+
        `显示：卦网=${showHexNet?"ON":"OFF"} ｜ 结构棱=${showStructure?"ON":"OFF"} ｜ 隐黄=${hideYellow?"ON":"OFF"} ｜ 标签=${showLabels?"ON":"OFF"} ｜ 自动4D=${auto4d?"ON":"OFF"}`;
    }
    if (!selKey) hudDetail.innerHTML = "";
  }

  // ====== 投影 ======
  function rotate3D(p){
    let x = p.x * zoom, y = p.y * zoom, z = p.z * zoom;

    const cy = Math.cos(rotY), sy = Math.sin(rotY);
    const x1 = x*cy + z*sy;
    const z1 = -x*sy + z*cy;

    const cx = Math.cos(rotX), sx = Math.sin(rotX);
    const y2 = y*cx - z1*sx;
    const z2 = y*sx + z1*cx;

    return {x:x1, y:y2, z:z2};
  }

  function getOrthoScale(){
    return 0.42 * Math.min(W,H) / Math.max(1e-6, sceneMaxAbs);
  }

  function project(p3){
    const pr = rotate3D(p3);
    if (projMode === "ortho"){
      const s = getOrthoScale();
      return { x: pr.x*s + W/2, y: -pr.y*s + H/2, z: pr.z, k:s };
    } else {
      const cameraDist = sceneMaxAbs * 4.2 + 2.0;
      const fov = Math.min(W,H) * 1.25;
      const z = pr.z + cameraDist;
      const k = fov / z;
      return { x: pr.x*k + W/2, y: -pr.y*k + H/2, z, k };
    }
  }

  // ====== 4D rotate & project ======
  function rotPlane(v, i, j, ang){
    const c=Math.cos(ang), s=Math.sin(ang);
    const a=v[i], b=v[j];
    v[i]=a*c - b*s;
    v[j]=a*s + b*c;
  }
  function rotate4D(base4){
    const v=[base4.x,base4.y,base4.z,base4.w];
    rotPlane(v,0,3,aXW);
    rotPlane(v,1,3,aYW);
    rotPlane(v,1,2,aYZ);
    return v;
  }
  function project4Dto3D(v4){
    const w=v4[3];
    const f = W_DIST / (W_DIST - w);
    return { x:v4[0]*f, y:v4[1]*f, z:v4[2]*f };
  }

  // ====== Hit test ======
  let lastProjCache=null;
  function hitTest(px,py, projCache){
    let best=null, bestD2=Infinity;
    for (const v of vertices){
      if (!v.pickable) continue;
      const p = projCache.get(v.key);
      if (!p) continue;
      const r = Math.max(9, 12*(p.k/150));
      const dx=px-p.x, dy=py-p.y;
      const d2=dx*dx+dy*dy;
      if (d2<r*r && d2<bestD2){ bestD2=d2; best=v.key; }
    }
    return best;
  }

  // ====== render ======
  function render(ts){
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.clearRect(0,0,W,H);

    // 64模式：可选自动4D旋转
    if (mode==="hex64"){
      if (lastTs==null) lastTs=ts;
      const dt = ts-lastTs; lastTs=ts;
      if (auto4dEl.checked){
        aXW += dt*0.00055;
        aYW += dt*0.00035;
        aYZ += dt*0.00045;
      }
    }

    // 本帧 3D位置
    const pos3ByKey = new Map();
    if (mode==="bagua"){
      for (const v of vertices) pos3ByKey.set(v.key, v.world);
    } else {
      for (const v of vertices){
        const v4 = rotate4D(v.base4);
        const p3 = project4Dto3D(v4);
        pos3ByKey.set(v.key, p3);
      }
    }

    // projection cache
    const projCache = new Map();
    for (const v of vertices){
      const p3 = pos3ByKey.get(v.key);
      if (!p3) continue;
      projCache.set(v.key, project(p3));
    }
    lastProjCache = projCache;

    // edge draw list by toggles
    const showHexNet = (mode==="hex64") ? !!showHexNetEl.checked : true;
    const showStructure = (mode==="hex64") ? !!showStructureEl.checked : true;

    const drawableEdges = edges.filter(e => {
      if (mode==="bagua") return e.type==="edge";
      if (e.type==="hex") return showHexNet;
      if (e.type==="edge64" || e.type==="wlink") return showStructure;
      return false;
    });

    // sort edges by depth
    const edgesSorted = drawableEdges.map(e=>{
      const pa=projCache.get(e.a), pb=projCache.get(e.b);
      const z = ((pa?.z??1e9)+(pb?.z??1e9))*0.5;
      return {e,pa,pb,z};
    }).sort((a,b)=>b.z-a.z);

    // helper: selection incident?
    function isIncident(e){
      if (!selKey) return false;
      return e.a===selKey || e.b===selKey;
    }

    // draw edges
    for (const it of edgesSorted){
      const {e,pa,pb}=it;
      if (!pa||!pb) continue;
      const hi = isIncident(e);

      ctx.beginPath();
      ctx.moveTo(pa.x,pa.y);
      ctx.lineTo(pb.x,pb.y);

      if (mode==="hex64" && e.type==="hex"){
        ctx.setLineDash([6,6]);
        ctx.lineWidth = hi ? 4.8 : 2.0;
        ctx.strokeStyle = hi ? COLOR_HI : COLOR_NET;
        ctx.stroke();
        ctx.setLineDash([]);
        continue;
      }

      if (mode==="hex64" && e.type==="wlink"){
        ctx.setLineDash([10,8]);
        ctx.lineWidth = hi ? 4.6 : 2.2;
        ctx.strokeStyle = hi ? COLOR_HI : COLOR_WLINK;
        ctx.stroke();
        ctx.setLineDash([]);
        continue;
      }

      // structure/bagua edges use yin/yang
      ctx.lineWidth = hi ? 6.0 : 3.0;
      ctx.strokeStyle = hi ? COLOR_HI : (e.val===0 ? COLOR_YANG : COLOR_YIN);
      ctx.stroke();
    }

    // draw vertices
    const hideYellow = (mode==="hex64") ? !!hideYellowEl.checked : false;
    const showLabels64 = (mode==="hex64") ? !!showLabels64El.checked : true;

    const vertsSorted = vertices.map(v=>({v,p:projCache.get(v.key)}))
      .filter(x=>!!x.p)
      .sort((a,b)=>b.p.z-a.p.z);

    for (const {v,p} of vertsSorted){
      const isSel = (selKey===v.key);
      const r = 7 + (p.k/110);

      // node color
      let fill = COLOR_NODE;
      if (mode==="bagua"){
        fill = isSel ? COLOR_HI : COLOR_NODE;
      } else {
        if (isSel) fill = COLOR_HI;
        else if (v.role==="true") fill = COLOR_TRUE;
        else {
          // real layer
          fill = hideYellow ? COLOR_NEUTRAL : COLOR_REAL;
        }
      }

      ctx.beginPath();
      ctx.arc(p.x,p.y, isSel ? r*1.25 : r, 0, Math.PI*2);
      ctx.fillStyle = fill;
      ctx.globalAlpha = 0.92;
      ctx.fill();
      ctx.globalAlpha = 1;

      // labels
      let showLabel = false;
      if (mode==="bagua"){
        showLabel = v.showLabel;
      } else {
        // 默认不显示标签（除非用户打开）
        showLabel = showLabels64 || isSel;
        // 如果隐藏黄色，则 real 的标签默认不显示（除非被选中）
        if (hideYellow && v.role==="real" && !isSel) showLabel = false;
      }

      if (showLabel){
        ctx.fillStyle = COLOR_LABEL;
        ctx.font = "13px system-ui, -apple-system, 'PingFang SC', 'Microsoft YaHei', sans-serif";
        ctx.textAlign = "center";
        ctx.textBaseline = "bottom";
        const text = `${v.name} ${v.bits}`;
        ctx.fillText(text, p.x, p.y - (isSel ? r*1.6 : r*1.25));
      }
    }

    requestAnimationFrame(render);
  }

  // ====== detail panel ======
  function updateDetail(){
    if (!selKey){ hudDetail.innerHTML=""; return; }
    const v = vByKey.get(selKey);
    if (!v){ hudDetail.innerHTML=""; return; }

    if (mode==="bagua"){
      hudDetail.innerHTML =
        `选中：<b>${v.name}</b> bits=<b class="mono">${v.bits}</b>（先天序号=${trigramIndex(v.bits)}）<br>`+
        `local(x,y,z)=(${v.local.x},${v.local.y},${v.local.z}) ｜ cube=${v.key.split("|")[0]}`;
      return;
    }

    // 64：显示该点的 8 条组合（叠加态）
    const isReal = (v.role==="real");
    const Lbits = isReal ? v.bits : null;
    const Ubits = (!isReal) ? v.bits : null;

    // collect opposite vertices
    const reals = vertices.filter(x=>x.role==="real").slice().sort((a,b)=>a.bits.localeCompare(b.bits));
    const trues = vertices.filter(x=>x.role==="true").slice().sort((a,b)=>a.bits.localeCompare(b.bits));

    if (isReal){
      let html = `选中：<b>本我(下卦点)</b> 下卦=<b>${v.name}</b> <span class="mono">${Lbits}</span><br>`;
      html += `<div style="margin-top:6px; font-weight:900;">该点的 8 条组合（=64卦中的 8 卦）：</div>`;
      const invL = invertBits3(Lbits);
      for (const tv of trues){
        const U = tv.bits;
        const hexBits = `${U}${Lbits}`;
        const num = (parseInt(hexBits,2)&63)+1;
        const mask = xorBits3(U, invL);
        const palace = bitsToName[mask];
        html += `上${tv.name}(<span class="mono">${U}</span>) + 下${v.name}(<span class="mono">${Lbits}</span>) `
              + `= <span class="mono">${hexBits}</span> #<b>${num}</b> ｜ 宫=<b>${palace}</b>(<span class="mono">${mask}</span>)<br>`;
      }
      hudDetail.innerHTML = html;
    } else {
      let html = `选中：<b>真我(上卦点)</b> 上卦=<b>${v.name}</b> <span class="mono">${Ubits}</span><br>`;
      html += `<div style="margin-top:6px; font-weight:900;">该点的 8 条组合（=64卦中的 8 卦）：</div>`;
      for (const rv of reals){
        const L = rv.bits;
        const hexBits = `${Ubits}${L}`;
        const num = (parseInt(hexBits,2)&63)+1;
        const invL = invertBits3(L);
        const mask = xorBits3(Ubits, invL);
        const palace = bitsToName[mask];
        html += `上${v.name}(<span class="mono">${Ubits}</span>) + 下${rv.name}(<span class="mono">${L}</span>) `
              + `= <span class="mono">${hexBits}</span> #<b>${num}</b> ｜ 宫=<b>${palace}</b>(<span class="mono">${mask}</span>)<br>`;
      }
      hudDetail.innerHTML = html;
    }
  }

  // ====== input ======
  const pointers = new Map();
  let pointerDown = null;
  let pinchStart = null;

  canvas.addEventListener("pointerdown", (e)=>{
    canvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    pointerDown = {x:e.clientX, y:e.clientY, t:performance.now()};
    if (pointers.size===2){
      const pts=[...pointers.values()];
      pinchStart = {dist:Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y), zoom};
    }
  });

  canvas.addEventListener("pointermove", (e)=>{
    if (!pointers.has(e.pointerId)) return;
    const prev = pointers.get(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

    if (pointers.size===1){
      const dx = e.clientX - prev.x;
      const dy = e.clientY - prev.y;
      rotY += dx*0.008;
      rotX += dy*0.008;     // ✅ 取消俯仰 clamp（旋转不受限）
    } else if (pointers.size===2 && pinchStart){
      const pts=[...pointers.values()];
      const dist=Math.hypot(pts[0].x-pts[1].x, pts[0].y-pts[1].y);
      const factor = dist / pinchStart.dist;
      zoom = Math.max(0.55, Math.min(3.2, pinchStart.zoom*factor));
    }
  });

  canvas.addEventListener("pointerup", (e)=>{
    pointers.delete(e.pointerId);
    if (pointers.size<2) pinchStart=null;

    if (!pointerDown) return;
    const dx=e.clientX-pointerDown.x, dy=e.clientY-pointerDown.y;
    const dt=performance.now()-pointerDown.t;
    pointerDown=null;

    if (dt<350 && (dx*dx+dy*dy)<16*16){
      const pc = lastProjCache;
      if (!pc) return;
      const hit = hitTest(e.clientX, e.clientY, pc);
      if (!hit) return;
      selKey = (selKey===hit) ? null : hit;
      updateDetail();
    }
  });

  canvas.addEventListener("wheel",(e)=>{
    e.preventDefault();
    const delta=Math.sign(e.deltaY);
    zoom = Math.max(0.55, Math.min(3.2, zoom*(delta>0?0.92:1.08)));
  }, {passive:false});

  // ====== UI events ======
  btnMode8.addEventListener("click", ()=>{
    mode="bagua";
    buildScene();
    resetView();
  });
  btnMode64.addEventListener("click", ()=>{
    mode="hex64";
    buildScene();
    resetView();
  });

  btnOrtho.addEventListener("click", ()=>{
    projMode="ortho";
    updateHUD();
  });
  btnPersp.addEventListener("click", ()=>{
    projMode="persp";
    updateHUD();
  });
  btnSnap.addEventListener("click", ()=>{
    projMode="ortho";
    snapHexView();
    updateHUD();
  });
  btnReset.addEventListener("click", ()=>{
    resetView();
  });

  [mxp,mxn,myp,myn,mzp,mzn].forEach(el=> el.addEventListener("change", ()=>{ if(mode==="bagua") buildScene(); }));
  [showHexNetEl, showStructureEl, hideYellowEl, showLabels64El, auto4dEl].forEach(el=>{
    el.addEventListener("change", ()=>{ if(mode==="hex64") updateHUD(); });
  });

  // HUD collapse
  function setHudCollapsed(c){
    hud.classList.toggle("collapsed", c);
    btnHudToggle.textContent = c ? "☰" : "✕";
  }
  btnHudToggle.addEventListener("click", ()=>{
    setHudCollapsed(!hud.classList.contains("collapsed"));
  });

  // ====== resize ======
  function resize(){
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    W=window.innerWidth; H=window.innerHeight;
    canvas.width=Math.floor(W*DPR);
    canvas.height=Math.floor(H*DPR);
    canvas.style.width=W+"px";
    canvas.style.height=H+"px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener("resize", resize);

  // ====== init ======
  resize();
  buildScene();
  resetView();

  // 手机默认折叠HUD（不挡画面）
  if (window.innerWidth <= 640) setHudCollapsed(true);
  else setHudCollapsed(false);

  requestAnimationFrame(render);
})();
</script>
</body>
</html>
