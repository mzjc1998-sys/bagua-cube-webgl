<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>先天八卦 / 64卦：bit 立方体 + 宫视角</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#eef2f7; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }

    #hud{
      position:fixed; left:10px; top:10px; z-index:10;
      background:rgba(0,0,0,.56); color:#fff;
      padding:10px 12px; border-radius:14px;
      font:14px/1.35 system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
      max-width:min(640px, calc(100vw - 20px));
      backdrop-filter: blur(6px);
    }
    #hudHeader{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
    #hudTitle{ font-weight:900; }
    #hudBody{ margin-top:8px; }

    #hud.collapsed{ padding:8px 10px; max-width:min(260px, calc(100vw - 20px)); }
    #hud.collapsed #hudBody{ display:none; }

    .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:8px; }
    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:2px 8px; border-radius:999px; background:rgba(255,255,255,.12);
    }
    .sw{ width:14px; height:14px; border-radius:4px; display:inline-block; border:1px solid rgba(255,255,255,.35); }

    button{
      appearance:none; border:1px solid rgba(255,255,255,.25);
      background:rgba(255,255,255,.10);
      color:#fff; border-radius:10px;
      padding:6px 10px; cursor:pointer; font:inherit;
    }
    button.active{ background:rgba(255,255,255,.22); border-color:rgba(255,255,255,.45); }
    button:active{ transform:translateY(1px); }
    button:disabled{ opacity:.45; cursor:not-allowed; transform:none; }

    .mini{ padding:4px 8px; border-radius:999px; }
    .sep{ width:1px; height:22px; background:rgba(255,255,255,.2); }

    label{ display:inline-flex; align-items:center; gap:6px; }
    input[type="checkbox"]{ width:16px; height:16px; }
    .hint{ opacity:.85; font-size:12px; margin-top:8px; }
    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }

    #mirrorPanel, #hexPanel{
      margin-top:10px; padding-top:10px;
      border-top:1px solid rgba(255,255,255,.18);
    }
    #mirrorPanel{ display:none; }
    #hexPanel{ display:none; }

    #check{ margin-top:8px; opacity:.95; }
    #detail{ margin-top:8px; opacity:.98; }
    #detail b{ font-weight:900; }

    .palace-label{ font-weight:800; margin-right:4px; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div id="hud">
  <div id="hudHeader">
    <div id="hudTitle">bit 立方体：8卦 / 64卦（宫视角 + 超立方体）</div>
    <button id="btnHudToggle" class="mini">☰</button>
  </div>

  <div id="hudBody">
    <div class="row">
      <span class="chip"><span class="sw" style="background:#cfd6df;"></span>浅色=阳爻(0)</span>
      <span class="chip"><span class="sw" style="background:#1f2329;"></span>深色=阴爻(1)</span>
      <!-- 黄=坤宫 / 本我，下卦；蓝=乾宫 / 真我，上卦 -->
      <span class="chip"><span class="sw" style="background:#ffd24a;"></span>黄点=坤宫 / 本我(下卦)</span>
      <span class="chip"><span class="sw" style="background:#5ad6ff;"></span>蓝点=乾宫 / 真我(上卦)</span>
    </div>

    <div class="row">
      <button id="btnMode8">8卦</button>
      <button id="btnMode64" class="active">64卦</button>
      <span class="sep"></span>
      <button id="btnOrtho" class="active">正交</button>
      <button id="btnPersp">透视</button>
      <button id="btnSnap" class="mini">乾坤重合(六边形)</button>
      <button id="btnFlip" class="mini">上下翻转(底/顶)</button>
      <button id="btnUnfold" class="mini">展开超立方体</button>
      <button id="btnReset" class="mini">重置</button>
    </div>

    <div class="row" id="palaceRow">
      <span class="palace-label">宫视角(8卦)：</span>
      <button class="mini palaceBtn" data-palace="乾">乾</button>
      <button class="mini palaceBtn" data-palace="坤">坤</button>
      <button class="mini palaceBtn" data-palace="兑">兑</button>
      <button class="mini palaceBtn" data-palace="艮">艮</button>
      <button class="mini palaceBtn" data-palace="离">离</button>
      <button class="mini palaceBtn" data-palace="坎">坎</button>
      <button class="mini palaceBtn" data-palace="震">震</button>
      <button class="mini palaceBtn" data-palace="巽">巽</button>
      <button id="btnPalaceFree" class="mini">自由旋转</button>
    </div>

    <div class="hint">
      交互：拖拽旋转｜滚轮/双指缩放｜点顶点查看叠加信息。<br/>
      宫视角：中心对角线两卦重叠，离玩家近的那个卦=当前宫。
    </div>

    <div id="mirrorPanel">
      <div style="font-weight:900; margin-bottom:6px;">镜像立方体（按面生成，8卦模式）</div>
      <div class="row">
        <label><input id="mxp" type="checkbox">+X</label>
        <label><input id="mxn" type="checkbox">-X</label>
        <label><input id="myp" type="checkbox">+Y</label>
        <label><input id="myn" type="checkbox">-Y</label>
        <label><input id="mzp" type="checkbox">+Z</label>
        <label><input id="mzn" type="checkbox">-Z</label>
      </div>
      <div class="hint">勾选后以该面四顶点为“共享面”，生成镜像 cube，用来拼接八宫结构。</div>
    </div>

    <div id="hexPanel">
      <div style="font-weight:900; margin-bottom:6px;">64卦（本我 × 真我 的超立方体）</div>
      <div class="row">
        <!-- 默认只开结构棱 -->
        <label><input id="showHexNet" type="checkbox">显示64卦虚线卦网</label>
        <label><input id="showStructure" type="checkbox" checked>显示结构棱</label>
      </div>
      <div class="row">
        <label><input id="hideYellow" type="checkbox">隐藏黄色卦象</label>
        <label><input id="showLabels64" type="checkbox" checked>显示主顶点卦名/bit</label>
        <label><input id="auto4d" type="checkbox">自动四维旋转</label>
      </div>
      <div class="hint">
        折叠：两个 3D 立方体（坤宫=黄，本我；乾宫=蓝，真我）在四维中叠加。<br/>
        展开：中心黄 cube + 6 个镜像 cube + 底部蓝 cube，形成 8 立方体展开图。
      </div>
    </div>

    <div id="check"></div>
    <div id="detail"></div>
  </div>
</div>

<script>
(() => {
  // ====== 配置持久化 ======
  const STORAGE_KEY = "bagua_cube_settings_v1";

  // ====== 先天八卦映射 ======
  const bitsToName = {
    "000":"乾","001":"兑","010":"离","011":"震",
    "100":"巽","101":"坎","110":"艮","111":"坤"
  };
  const trigramBits = ["000","001","010","011","100","101","110","111"];

  // ====== 颜色 ======
  const COLOR_YANG = "#cfd6df";
  const COLOR_YIN  = "#1f2329";
  const COLOR_NODE = "#0b0f14";
  const COLOR_LABEL = "#0b0f14";
  const COLOR_HI = "#ffb020";
  const COLOR_REAL = "#ffd24a"; // 坤宫 / 本我
  const COLOR_TRUE = "#5ad6ff"; // 乾宫 / 真我
  const COLOR_NEUTRAL = "rgba(20,25,30,.55)";
  const COLOR_NET = "rgba(30,40,55,.22)";
  const COLOR_WLINK = "rgba(40,50,60,.35)";
  const COLOR_NETCUBE = "rgba(110,130,150,.55)";

  // ====== DOM ======
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const hud = document.getElementById("hud");
  const btnHudToggle = document.getElementById("btnHudToggle");

  const btnMode8  = document.getElementById("btnMode8");
  const btnMode64 = document.getElementById("btnMode64");
  const btnOrtho  = document.getElementById("btnOrtho");
  const btnPersp  = document.getElementById("btnPersp");
  const btnSnap   = document.getElementById("btnSnap");
  const btnFlip   = document.getElementById("btnFlip");
  const btnUnfold = document.getElementById("btnUnfold");
  const btnReset  = document.getElementById("btnReset");

  const palaceRow = document.getElementById("palaceRow");
  const palaceBtns = Array.from(document.querySelectorAll(".palaceBtn"));
  const btnPalaceFree = document.getElementById("btnPalaceFree");

  const mirrorPanel = document.getElementById("mirrorPanel");
  const hexPanel    = document.getElementById("hexPanel");
  const mxp = document.getElementById("mxp");
  const mxn = document.getElementById("mxn");
  const myp = document.getElementById("myp");
  const myn = document.getElementById("myn");
  const mzp = document.getElementById("mzp");
  const mzn = document.getElementById("mzn");

  const showHexNetEl   = document.getElementById("showHexNet");
  const showStructureEl= document.getElementById("showStructure");
  const hideYellowEl   = document.getElementById("hideYellow");
  const showLabels64El = document.getElementById("showLabels64");
  const auto4dEl       = document.getElementById("auto4d");

  const hudCheck  = document.getElementById("check");
  const hudDetail = document.getElementById("detail");

  // ====== 视图状态 ======
  let W=0, H=0, DPR=1;
  let mode = "hex64";          // 默认 64 卦视图
  let projMode = "ortho";
  let rotX = 0;
  let rotY = 0;
  let rotZ = Math.PI;
  let zoom = 1.05;

  // 4D / unfold
  let unfold = 0;
  let unfoldTarget = 0;
  let unfoldAnim = null;
  const UNFOLD_DUR = 1200;
  const W_DIST = 4.0;
  let aXW=0, aYW=0, aYZ=0;
  let lastTs=null;

  // 场景
  let vertices = [];
  let edges = [];
  let vByKey = new Map();
  let sceneMaxAbs = 3.2;
  let selKey = null;
  let lastProjCache = null;

  // 宫视角基础矩阵
  const ID_MAT = [1,0,0, 0,1,0, 0,0,1];
  let palaceBases = {};
  let currentPalace = "乾";
  let palaceMat = ID_MAT.slice();

  // ====== 工具函数 ======
  function resize(){
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    W = window.innerWidth; H = window.innerHeight;
    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener("resize", () => { resize(); });

  function clamp(v,min,max){ return v<min?min:(v>max?max:v); }
  function clamp01(v){ return clamp(v,0,1); }
  function lerp(a,b,t){ return a + (b-a)*t; }
  function easeInOutCubic(t){
    t = clamp01(t);
    return t<0.5 ? 4*t*t*t : 1-Math.pow(-2*t+2,3)/2;
  }
  function trigramIndex(bits){ return (parseInt(bits,2)&7)+1; }
  function invertBits3(bits){ return bits.replace(/[01]/g, c => c==="0"?"1":"0"); }

  function vecAdd(a,b){ return {x:a.x+b.x,y:a.y+b.y,z:a.z+b.z}; }
  function vecSub(a,b){ return {x:a.x-b.x,y:a.y-b.y,z:a.z-b.z}; }
  function vecScale(v,s){ return {x:v.x*s,y:v.y*s,z:v.z*s}; }
  function vecDot(a,b){ return a.x*b.x + a.y*b.y + a.z*b.z; }
  function vecLength(v){ return Math.sqrt(v.x*v.x + v.y*v.y + v.z*v.z); }
  function vecNorm(v){ const L=vecLength(v)||1; return {x:v.x/L,y:v.y/L,z:v.z/L}; }
  function vecCross(a,b){
    return {x:a.y*b.z - a.z*b.y,
            y:a.z*b.x - a.x*b.z,
            z:a.x*b.y - a.y*b.x};
  }

  function keyOf(cubeId,x,y,z){ return cubeId+"|"+x+","+y+","+z; }

  // ====== HUD 折叠（要在持久化之前定义） ======
  function setHudCollapsed(collapsed){
    hud.classList.toggle("collapsed", !!collapsed);
    btnHudToggle.textContent = collapsed ? "☰" : "✕";
  }

  // ====== 持久化 ======
  function saveSettings(){
    try{
      const data = {
        hudCollapsed: hud.classList.contains("collapsed"),
        mode,
        projMode,
        rot:{x:rotX,y:rotY,z:rotZ},
        zoom,
        currentPalace,
        mirrors:{
          mxp: mxp.checked,
          mxn: mxn.checked,
          myp: myp.checked,
          myn: myn.checked,
          mzp: mzp.checked,
          mzn: mzn.checked
        },
        hex:{
          showHexNet: showHexNetEl.checked,
          showStructure: showStructureEl.checked,
          hideYellow: hideYellowEl.checked,
          showLabels64: showLabels64El.checked,
          auto4d: auto4dEl.checked
        },
        unfoldTarget
      };
      localStorage.setItem(STORAGE_KEY, JSON.stringify(data));
    }catch(e){}
  }

  function loadSettings(){
    let ok=false;
    try{
      const raw = localStorage.getItem(STORAGE_KEY);
      if (!raw) return false;
      const data = JSON.parse(raw);
      ok = true;

      if (typeof data.mode==="string") mode=data.mode;
      if (typeof data.projMode==="string") projMode=data.projMode;
      if (data.rot){
        if (typeof data.rot.x==="number") rotX=data.rot.x;
        if (typeof data.rot.y==="number") rotY=data.rot.y;
        if (typeof data.rot.z==="number") rotZ=data.rot.z;
      }
      if (typeof data.zoom==="number") zoom=data.zoom;
      if ("currentPalace" in data) currentPalace=data.currentPalace;

      if (data.mirrors){
        mxp.checked=!!data.mirrors.mxp;
        mxn.checked=!!data.mirrors.mxn;
        myp.checked=!!data.mirrors.myp;
        myn.checked=!!data.mirrors.myn;
        mzp.checked=!!data.mirrors.mzp;
        mzn.checked=!!data.mirrors.mzn;
      }
      if (data.hex){
        showHexNetEl.checked   = !!data.hex.showHexNet;
        showStructureEl.checked= !!data.hex.showStructure;
        hideYellowEl.checked   = !!data.hex.hideYellow;
        showLabels64El.checked = !!data.hex.showLabels64;
        auto4dEl.checked       = !!data.hex.auto4d;
      }
      if (typeof data.unfoldTarget==="number"){
        unfoldTarget = clamp01(data.unfoldTarget);
        unfold = unfoldTarget;
      }

      if (data.hudCollapsed) setHudCollapsed(true);
    }catch(e){}
    return ok;
  }

  // ====== 三爻卦在立方体中的基础坐标 (按照你的先天序编码) ======
  const trigramPos = {};
  (function initTrigramPos(){
    for (const bits of trigramBits){
      const b0=bits[0], b1=bits[1], b2=bits[2];
      const x = (b2==="1")? 1:-1;
      const y = (b0==="1")? 1:-1;
      const z = (b1==="1")? 1:-1;
      trigramPos[bits] = {x,y,z};
    }
  })();

  function neighborBitsForUp(bits){
    const b0=bits[0], b1=bits[1], b2=bits[2];
    const flipped = b1==="0" ? "1" : "0";
    return ""+b0+flipped+b2;
  }

  function basisForPalace(frontBits, backBits){
    const pA = trigramPos[frontBits];
    const pB = trigramPos[backBits];
    const forward = vecNorm(vecSub(pB,pA));

    const qBits = neighborBitsForUp(frontBits);
    const q = trigramPos[qBits];
    let upCand = vecSub(q,pA);
    const projLen = vecDot(upCand,forward);
    upCand = vecSub(upCand, vecScale(forward,projLen));
    const up = vecNorm(upCand);
    let right = vecCross(up,forward);
    right = vecNorm(right);

    return [
      right.x,  right.y,  right.z,
      up.x,     up.y,     up.z,
      forward.x,forward.y,forward.z
    ];
  }

  function computePalaceBases(){
    const pairs = {
      "乾":["000","111"],
      "坤":["111","000"],
      "兑":["001","110"],
      "艮":["110","001"],
      "离":["010","101"],
      "坎":["101","010"],
      "震":["011","100"],
      "巽":["100","011"]
    };
    palaceBases = {};
    for (const name in pairs){
      const [f,b] = pairs[name];
      palaceBases[name] = basisForPalace(f,b);
    }
  }

  function applyPalaceMat(p){
    if (mode!=="bagua" || !palaceMat) return p;
    const m = palaceMat;
    return {
      x: m[0]*p.x + m[1]*p.y + m[2]*p.z,
      y: m[3]*p.x + m[4]*p.y + m[5]*p.z,
      z: m[6]*p.x + m[7]*p.y + m[8]*p.z
    };
  }

  // 4D 旋转
  function rotPlane(v,i,j,ang){
    const c=Math.cos(ang), s=Math.sin(ang);
    const a=v[i], b=v[j];
    v[i]=a*c - b*s;
    v[j]=a*s + b*c;
  }
  function rotate4D(base4){
    const v=[base4.x,base4.y,base4.z,base4.w];
    rotPlane(v,0,3,aXW);
    rotPlane(v,1,3,aYW);
    rotPlane(v,1,2,aYZ);
    return v;
  }
  function project4Dto3D(v4){
    const w=v4[3];
    const f = W_DIST / (W_DIST - w);
    return {x:v4[0]*f, y:v4[1]*f, z:v4[2]*f};
  }

  // 3D 旋转 + 投影
  function rotate3D(p){
    let v = p;
    if (mode==="bagua") v = applyPalaceMat(p);
    let x = v.x * zoom;
    let y = v.y * zoom;
    let z = v.z * zoom;

    const cy=Math.cos(rotY), sy=Math.sin(rotY);
    let x1=x*cy+z*sy, z1=-x*sy+z*cy;

    const cx=Math.cos(rotX), sx=Math.sin(rotX);
    let y2=y*cx - z1*sx, z2=y*sx + z1*cx;

    const cz=Math.cos(rotZ), sz=Math.sin(rotZ);
    let x3=x1*cz - y2*sz, y3=x1*sz + y2*cz;

    return {x:x3,y:y3,z:z2};
  }

  function boundAbs(){
    if (mode==="hex64"){
      const folded=3.2, unfolded=6.2;
      return lerp(folded,unfolded,unfold);
    }
    return sceneMaxAbs;
  }
  function getOrthoScale(){
    return 0.42 * Math.min(W,H) / Math.max(1e-6, boundAbs());
  }
  function project(p3){
    const pr = rotate3D(p3);
    if (projMode==="ortho"){
      const s=getOrthoScale();
      return {x:pr.x*s+W/2, y:-pr.y*s+H/2, z:pr.z, k:s};
    } else {
      const cameraDist = boundAbs()*4.2+2.0;
      const fov = Math.min(W,H)*1.25;
      const z = pr.z + cameraDist;
      const k = fov / z;
      return {x:pr.x*k+W/2, y:-pr.y*k+H/2, z, k};
    }
  }

  // hit test
  function hitTest(px,py,projCache){
    let best=null, bestD2=Infinity;
    for (const v of vertices){
      if (!v.pickable) continue;
      const p=projCache.get(v.key);
      if (!p) continue;
      const r=Math.max(9,12*(p.k/150));
      const dx=px-p.x, dy=py-p.y, d2=dx*dx+dy*dy;
      if (d2<r*r && d2<bestD2){ bestD2=d2; best=v.key; }
    }
    return best;
  }

  // ===== build 8卦场景 =====
  function worldPosCube(cube,xBit,yBit,zBit){
    const bx = cube.ax.x.mirror?(1-xBit):xBit;
    const by = cube.ax.y.mirror?(1-yBit):yBit;
    const bz = cube.ax.z.mirror?(1-zBit):zBit;
    return {
      x: cube.ax.x.base + 2*bx,
      y: cube.ax.y.base + 2*by,
      z: cube.ax.z.base + 2*bz
    };
  }
  function makeCubeInstance({id,axisBase={x:-1,y:-1,z:-1},axisMirror={x:false,y:false,z:false},showLabels=true,pickable=true}){
    return {
      id,showLabels,pickable,
      ax:{
        x:{base:axisBase.x,mirror:!!axisMirror.x},
        y:{base:axisBase.y,mirror:!!axisMirror.y},
        z:{base:axisBase.z,mirror:!!axisMirror.z}
      }
    };
  }
  function buildSceneBagua(){
    vertices=[]; edges=[]; vByKey.clear(); sceneMaxAbs=1;
    const cubes=[];
    const base=makeCubeInstance({id:"B",showLabels:true,pickable:true});
    cubes.push(base);

    const mirrorCfgs=[
      {on:mxp.checked,id:"Mx+",axis:"x",base: 1,mirror:true},
      {on:mxn.checked,id:"Mx-",axis:"x",base:-3,mirror:true},
      {on:myp.checked,id:"My+",axis:"y",base: 1,mirror:true},
      {on:myn.checked,id:"My-",axis:"y",base:-3,mirror:true},
      {on:mzp.checked,id:"Mz+",axis:"z",base: 1,mirror:true},
      {on:mzn.checked,id:"Mz-",axis:"z",base:-3,mirror:true}
    ];
    for (const m of mirrorCfgs){
      if (!m.on) continue;
      const axisBase={x:-1,y:-1,z:-1};
      const axisMirror={x:false,y:false,z:false};
      axisBase[m.axis]=m.base;
      axisMirror[m.axis]=true;
      cubes.push(makeCubeInstance({id:m.id,axisBase,axisMirror,showLabels:false,pickable:false}));
    }

    for (const cube of cubes){
      for (let x=0;x<=1;x++)
        for (let y=0;y<=1;y++)
          for (let z=0;z<=1;z++){
            const bits=""+y+z+x;
            const w=worldPosCube(cube,x,y,z);
            const key=keyOf(cube.id,x,y,z);
            const v={
              key,mode:"bagua",cubeId:cube.id,
              role:"bagua",pickable:cube.pickable,showLabel:cube.showLabels,
              local:{x,y,z}, bits, name:bitsToName[bits], world:w
            };
            vertices.push(v);
            vByKey.set(key,v);
            sceneMaxAbs=Math.max(sceneMaxAbs,Math.abs(w.x),Math.abs(w.y),Math.abs(w.z));
          }

      for (let y=0;y<=1;y++) for (let z=0;z<=1;z++)
        edges.push({type:"edge8",cubeId:cube.id,val:y,a:keyOf(cube.id,0,y,z),b:keyOf(cube.id,1,y,z)});
      for (let x=0;x<=1;x++) for (let z=0;z<=1;z++)
        edges.push({type:"edge8",cubeId:cube.id,val:z,a:keyOf(cube.id,x,0,z),b:keyOf(cube.id,x,1,z)});
      for (let x=0;x<=1;x++) for (let y=0;y<=1;y++)
        edges.push({type:"edge8",cubeId:cube.id,val:x,a:keyOf(cube.id,x,y,0),b:keyOf(cube.id,x,y,1)});
    }
  }

  // ===== build 64 卦场景(tesseract) =====
  function buildSceneHex64(){
    vertices=[]; edges=[]; vByKey.clear(); sceneMaxAbs=6.0;
    const roles=[{role:"real",w:+1},{role:"true",w:-1}];

    for (const R of roles){
      for (let x=0;x<=1;x++)
        for (let y=0;y<=1;y++)
          for (let z=0;z<=1;z++){
            const coordBits=""+y+z+x;
            const bits=(R.role==="real")?coordBits:invertBits3(coordBits);
            const key=`${R.role}|${x},${y},${z}`;
            const base4={x:x?1:-1,y:y?1:-1,z:z?1:-1,w:R.w};
            const v={key,mode:"hex64",role:R.role,pickable:true,showLabel:true,
                     local:{x,y,z},coordBits,bits,name:bitsToName[bits],base4};
            vertices.push(v); vByKey.set(key,v);
          }
    }
    function addStruct(role){
      for (let y=0;y<=1;y++) for (let z=0;z<=1;z++)
        edges.push({type:"edge64",role,val:y,a:`${role}|0,${y},${z}`,b:`${role}|1,${y},${z}`});
      for (let x=0;x<=1;x++) for (let z=0;z<=1;z++)
        edges.push({type:"edge64",role,val:z,a:`${role}|${x},0,${z}`,b:`${role}|${x},1,${z}`});
      for (let x=0;x<=1;x++) for (let y=0;y<=1;y++)
        edges.push({type:"edge64",role,val:x,a:`${role}|${x},${y},0`,b:`${role}|${x},${y},1`});
    }
    addStruct("real");
    addStruct("true");

    for (let x=0;x<=1;x++)
      for (let y=0;y<=1;y++)
        for (let z=0;z<=1;z++)
          edges.push({type:"wlink",a:`real|${x},${y},${z}`,b:`true|${x},${y},${z}`});

    const realVs=vertices.filter(v=>v.role==="real");
    const trueVs=vertices.filter(v=>v.role==="true");
    for (const rv of realVs){
      const L=rv.bits;
      for (const tv of trueVs){
        const U=tv.bits;
        const hexBits=U+L;
        const num=(parseInt(hexBits,2)&63)+1;
        edges.push({type:"hex",a:rv.key,b:tv.key,hexBits,hexNum:num});
      }
    }
  }

  // ===== buildScene =====
  function buildScene(){
    selKey=null;
    if (mode==="bagua") buildSceneBagua();
    else buildSceneHex64();
    updateHUD();
    hudDetail.innerHTML="";
  }

  // ===== HUD =====
  function updateHUD(){
    btnMode8.classList.toggle("active",mode==="bagua");
    btnMode64.classList.toggle("active",mode==="hex64");
    btnOrtho.classList.toggle("active",projMode==="ortho");
    btnPersp.classList.toggle("active",projMode==="persp");

    mirrorPanel.style.display = (mode==="bagua")?"block":"none";
    hexPanel.style.display    = (mode==="hex64")?"block":"none";
    palaceRow.style.display   = (mode==="bagua")?"flex":"none";

    if (mode==="hex64"){
      const unfolding=(unfoldTarget>0.5 || unfold>0.5 || !!unfoldAnim);
      btnUnfold.textContent = unfolding ? "折叠超立方体" : "展开超立方体";
    } else {
      btnUnfold.textContent="展开超立方体";
    }

    for (const btn of palaceBtns){
      btn.classList.toggle("active",mode==="bagua" && currentPalace===btn.dataset.palace);
    }
    btnPalaceFree.classList.toggle("active",mode==="bagua" && !currentPalace);

    if (mode==="bagua"){
      hudCheck.innerHTML =
        `模式：<b>8卦</b> ｜ 投影：<b>${projMode==="ortho"?"正交":"透视"}</b>`+
        (currentPalace?` ｜ 宫视角：<b>${currentPalace}宫</b>`:" ｜ 宫视角：自由");
    } else {
      hudCheck.innerHTML =
        `模式：<b>64卦</b> ｜ 投影：<b>${projMode==="ortho"?"正交":"透视"}</b>`+
        ` ｜ 展开：<b>${Math.round(unfold*100)}%</b>`;
    }
  }

  // ===== detail =====
  function updateDetail(){
    if (!selKey){ hudDetail.innerHTML=""; return; }
    const v=vByKey.get(selKey);
    if (!v){ hudDetail.innerHTML=""; return; }

    if (mode==="bagua"){
      hudDetail.innerHTML =
        `选中：<b>${v.name}</b> bits=<b class="mono">${v.bits}</b>（先天序=${trigramIndex(v.bits)}）<br>`+
        `local(x,y,z)=(${v.local.x},${v.local.y},${v.local.z}) ｜ cube=${v.cubeId}`;
      return;
    }

    const isReal=(v.role==="real");
    const thisRole=isReal?"坤宫 / 本我(下卦点)":"乾宫 / 真我(上卦点)";
    const otherRole=isReal?"乾宫(上卦)":"坤宫(下卦)";
    const thisBits=v.bits;
    const others=vertices.filter(x=>x.role!==v.role)
                         .slice().sort((a,b)=>a.bits.localeCompare(b.bits));

    let html=`选中：<b>${thisRole}</b> 卦=<b>${v.name}</b> <span class="mono">${thisBits}</span><br>`;
    html+=`<div style="margin-top:6px; font-weight:900;">与${otherRole}的 8 条叠加线：</div>`;
    for (const o of others){
      const U = isReal ? o.bits : thisBits;
      const L = isReal ? thisBits : o.bits;
      const hexBits=U+L;
      const num=(parseInt(hexBits,2)&63)+1;
      html += `${isReal?"上":"下"}${o.name}(<span class="mono">${o.bits}</span>) `
           + `× ${isReal?"下":"上"}${v.name}(<span class="mono">${thisBits}</span>) `
           + `= <span class="mono">${hexBits}</span> #<b>${num}</b><br>`;
    }
    hudDetail.innerHTML=html;
  }

  // ===== 视角控制 =====
  function snapHexViewFor64(){
    rotY=-Math.PI/4;
    rotX=Math.atan(1/Math.sqrt(2));
    rotZ=Math.PI;
  }
  function resetView(){
    projMode="ortho";
    zoom=(mode==="hex64")?1.05:1.12;
    if (mode==="hex64") snapHexViewFor64();
    else { rotX=rotY=0; rotZ=Math.PI; }
    updateHUD();
    saveSettings();
  }
  function toggleFlip(){
    const zNorm=((rotZ%(2*Math.PI))+2*Math.PI)%(2*Math.PI);
    rotZ=(Math.abs(zNorm)<1e-3)?Math.PI:0;
    updateHUD(); saveSettings();
  }
  function startUnfold(to){
    unfoldTarget=to;
    unfoldAnim={start:performance.now(),from:unfold,to,dur:UNFOLD_DUR};
    saveSettings();
  }
  function toggleUnfold(){
    if (mode!=="hex64") return;
    const to=(unfoldTarget>0.5 || unfold>0.5)?0:1;
    startUnfold(to);
    updateHUD();
  }
  function setPalace(name, resetRot=true){
    if (!name){ currentPalace=null; palaceMat=ID_MAT.slice(); }
    else { currentPalace=name; palaceMat=palaceBases[name] || ID_MAT.slice(); }
    if (resetRot){ rotX=rotY=0; rotZ=Math.PI; }
    updateHUD();
    saveSettings();
  }

  // ===== 渲染辅助：绘制展开的 6 个镜像立方体 =====
  function drawNetCubes(pos3ByKey){
    if (mode!=="hex64") return;
    if (!showStructureEl.checked) return;
    if (unfold <= 0.001) return;

    const p000 = pos3ByKey.get("real|0,0,0");
    const p100 = pos3ByKey.get("real|1,0,0");
    const p010 = pos3ByKey.get("real|0,1,0");
    const p001 = pos3ByKey.get("real|0,0,1");
    if (!p000 || !p100 || !p010 || !p001) return;

    const vx = vecSub(p100,p000);
    const vy = vecSub(p010,p000);
    const vz = vecSub(p001,p000);
    const lx = vecLength(vx), ly = vecLength(vy), lz = vecLength(vz);
    const edge = (lx+ly+lz)/3 || 1;
    const ux = vecScale(vx,1/(lx||1));
    const uy = vecScale(vy,1/(ly||1));
    const uz = vecScale(vz,1/(lz||1));

    // “一格”：两倍边长，乘以 unfold 作为动画
    const mag = edge * 2.1 * unfold;
    const shifts = [
      vecScale(ux, mag),
      vecScale(ux,-mag),
      vecScale(uy, mag),
      vecScale(uy,-mag),
      vecScale(uz, mag),
      vecScale(uz,-mag)
    ];

    ctx.save();
    ctx.lineWidth = 2;
    ctx.strokeStyle = COLOR_NETCUBE;
    ctx.globalAlpha = 0.45 + 0.35 * unfold;

    for (const s of shifts){
      for (const e of edges){
        if (e.type!=="edge64" || e.role!=="real") continue;
        const pa = pos3ByKey.get(e.a);
        const pb = pos3ByKey.get(e.b);
        if (!pa || !pb) continue;
        const pa2 = vecAdd(pa,s);
        const pb2 = vecAdd(pb,s);
        const Pa = project(pa2);
        const Pb = project(pb2);
        ctx.beginPath();
        ctx.moveTo(Pa.x,Pa.y);
        ctx.lineTo(Pb.x,Pb.y);
        ctx.stroke();
      }
    }

    ctx.restore();
  }

  // ===== 渲染循环 =====
  function render(ts){
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.clearRect(0,0,W,H);

    if (mode==="hex64"){
      if (lastTs==null) lastTs=ts;
      const dt=ts-lastTs; lastTs=ts;

      if (unfoldAnim){
        const t=(ts-unfoldAnim.start)/unfoldAnim.dur;
        const k=easeInOutCubic(t);
        unfold=lerp(unfoldAnim.from,unfoldAnim.to,k);
        if (t>=1){ unfold=unfoldAnim.to; unfoldAnim=null; }
      }
      if (auto4dEl.checked){
        aXW+=dt*0.00055;
        aYW+=dt*0.00035;
        aYZ+=dt*0.00045;
      }
    }

    const pos3ByKey=new Map();
    if (mode==="bagua"){
      for (const v of vertices) pos3ByKey.set(v.key,v.world);
    } else {
      for (const v of vertices){
        const v4=rotate4D(v.base4);
        const pFold=project4Dto3D(v4);
        // 关键：蓝色 true 立方体向“下方”展开，黄立方体在中间
        const offsetY = (v.role==="true") ? lerp(0, -4, unfold) : 0;
        const p3={x:pFold.x, y:pFold.y + offsetY, z:pFold.z};
        pos3ByKey.set(v.key,p3);
      }
    }

    const projCache=new Map();
    for (const v of vertices){
      const p3=pos3ByKey.get(v.key);
      if (!p3) continue;
      projCache.set(v.key,project(p3));
    }
    lastProjCache=projCache;

    const showHexNet = (mode==="hex64") && showHexNetEl.checked;
    const showStructure = (mode==="hex64") ? showStructureEl.checked : true;
    const hideYellow = (mode==="hex64") ? hideYellowEl.checked : false;
    const showLabels64 = (mode==="hex64") ? showLabels64El.checked : true;

    const drawableEdges=edges.filter(e=>{
      if (mode==="bagua") return e.type==="edge8";
      if (e.type==="hex") return showHexNet;
      if (e.type==="edge64" || e.type==="wlink") return showStructure;
      return false;
    });

    const edgesSorted=drawableEdges.map(e=>{
      const pa=projCache.get(e.a), pb=projCache.get(e.b);
      const z=((pa?.z??1e9)+(pb?.z??1e9))/2;
      return {e,pa,pb,z};
    }).sort((a,b)=>b.z-a.z);

    function incident(e){ return selKey && (e.a===selKey || e.b===selKey); }

    // 先画“中心 + 底部”的结构棱
    for (const it of edgesSorted){
      const {e,pa,pb}=it;
      if (!pa||!pb) continue;
      const hi=incident(e);
      ctx.beginPath(); ctx.moveTo(pa.x,pa.y); ctx.lineTo(pb.x,pb.y);

      if (mode==="hex64" && e.type==="hex"){
        ctx.setLineDash([6,6]);
        ctx.lineWidth=hi?4.6:2.0;
        ctx.strokeStyle=hi?COLOR_HI:COLOR_NET;
        ctx.stroke(); ctx.setLineDash([]); continue;
      }
      if (mode==="hex64" && e.type==="wlink"){
        ctx.setLineDash([10,8]);
        ctx.lineWidth=hi?4.6:2.2;
        ctx.strokeStyle=hi?COLOR_HI:COLOR_WLINK;
        ctx.stroke(); ctx.setLineDash([]); continue;
      }
      ctx.lineWidth=hi?6.0:3.0;
      ctx.strokeStyle=hi?COLOR_HI:(e.val===0?COLOR_YANG:COLOR_YIN);
      ctx.stroke();
    }

    // 再画 6 个镜像立方体（展开图）
    drawNetCubes(pos3ByKey);

    const vertsSorted=vertices.map(v=>({v,p:projCache.get(v.key)}))
      .filter(x=>!!x.p).sort((a,b)=>b.p.z-a.p.z);

    for (const {v,p} of vertsSorted){
      const isSel=(selKey===v.key);
      const r=7+(p.k/110);
      let fill=COLOR_NODE;
      if (mode==="bagua"){
        fill=isSel?COLOR_HI:COLOR_NODE;
      } else {
        if (isSel) fill=COLOR_HI;
        else if (v.role==="true") fill=COLOR_TRUE;
        else fill=hideYellow?COLOR_NEUTRAL:COLOR_REAL;
      }

      ctx.beginPath();
      ctx.arc(p.x,p.y,isSel?r*1.25:r,0,Math.PI*2);
      ctx.fillStyle=fill; ctx.globalAlpha=0.92; ctx.fill(); ctx.globalAlpha=1;

      let showLabel=false;
      if (mode==="bagua"){
        showLabel=v.showLabel;
      } else {
        showLabel=showLabels64 || isSel;
        if (hideYellow && v.role==="real" && !isSel) showLabel=false;
      }
      if (showLabel){
        ctx.fillStyle=COLOR_LABEL;
        ctx.font="13px system-ui, -apple-system, 'PingFang SC', 'Microsoft YaHei', sans-serif";
        ctx.textAlign="center"; ctx.textBaseline="bottom";
        ctx.fillText(v.name+" "+v.bits,p.x,p.y-(isSel?r*1.6:r*1.25));
      }
    }

    // 额外：标出两个主 cube 的“宫名”
    if (mode==="hex64"){
      let cr={x:0,y:0,z:0}, ct={x:0,y:0,z:0}, nr=0, nt=0;
      for (const v of vertices){
        const p3=pos3ByKey.get(v.key);
        if (!p3) continue;
        if (v.role==="real"){ cr=vecAdd(cr,p3); nr++; }
        else { ct=vecAdd(ct,p3); nt++; }
      }
      if (nr>0 && nt>0){
        cr=vecScale(cr,1/nr); ct=vecScale(ct,1/nt);
        const pr=project(cr), pt=project(ct);
        ctx.fillStyle="rgba(10,14,18,.9)";
        ctx.font="13px system-ui, -apple-system, 'PingFang SC', 'Microsoft YaHei', sans-serif";
        ctx.textAlign="center"; ctx.textBaseline="middle";
        ctx.fillText("坤宫(黄)",pr.x,pr.y);
        ctx.fillText("乾宫(蓝)",pt.x,pt.y);
      }
    }

    requestAnimationFrame(render);
  }

  // ===== 交互 =====
  const pointers=new Map();
  let pointerDown=null;
  let pinchStart=null;

  canvas.addEventListener("pointerdown",e=>{
    canvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
    pointerDown={x:e.clientX,y:e.clientY,t:performance.now()};
    if (pointers.size===2){
      const pts=[...pointers.values()];
      const dist=Math.hypot(pts[0].x-pts[1].x,pts[0].y-pts[1].y);
      pinchStart={dist,zoom};
    }
  });
  canvas.addEventListener("pointermove",e=>{
    if (!pointers.has(e.pointerId)) return;
    const prev=pointers.get(e.pointerId);
    pointers.set(e.pointerId,{x:e.clientX,y:e.clientY});
    if (pointers.size===1){
      const dx=e.clientX-prev.x, dy=e.clientY-prev.y;
      rotY+=dx*0.008;
      rotX+=dy*0.008; // 不限制俯仰
    } else if (pointers.size===2 && pinchStart){
      const pts=[...pointers.values()];
      const dist=Math.hypot(pts[0].x-pts[1].x,pts[0].y-pts[1].y);
      const factor=dist/pinchStart.dist;
      zoom=clamp(pinchStart.zoom*factor,0.55,3.2);
    }
  });
  canvas.addEventListener("pointerup",e=>{
    pointers.delete(e.pointerId);
    if (pointers.size<2) pinchStart=null;

    if (!pointerDown) return;
    const dx=e.clientX-pointerDown.x, dy=e.clientY-pointerDown.y;
    const dt=performance.now()-pointerDown.t;
    pointerDown=null;
    if (dt<350 && (dx*dx+dy*dy)<16*16){
      const pc=lastProjCache;
      if (!pc) return;
      const hit=hitTest(e.clientX,e.clientY,pc);
      if (!hit) return;
      selKey=(selKey===hit)?null:hit;
      updateDetail();
      saveSettings();
    } else {
      saveSettings();
    }
  });
  canvas.addEventListener("wheel",e=>{
    e.preventDefault();
    const delta=Math.sign(e.deltaY);
    zoom=clamp(zoom*(delta>0?0.92:1.08),0.55,3.2);
    saveSettings();
  },{passive:false});

  // ===== UI 事件 =====
  btnMode8.addEventListener("click",()=>{
    mode="bagua"; rotX=rotY=0; rotZ=Math.PI;
    unfold=unfoldTarget=0; selKey=null;
    buildScene(); saveSettings();
  });
  btnMode64.addEventListener("click",()=>{
    mode="hex64"; selKey=null;
    buildScene(); snapHexViewFor64(); saveSettings();
  });
  btnOrtho.addEventListener("click",()=>{ projMode="ortho"; updateHUD(); saveSettings(); });
  btnPersp.addEventListener("click",()=>{ projMode="persp"; updateHUD(); saveSettings(); });
  btnSnap.addEventListener("click",()=>{
    if (mode==="hex64") snapHexViewFor64();
    else setPalace(currentPalace||"乾");
    saveSettings();
  });
  btnFlip.addEventListener("click",toggleFlip);
  btnUnfold.addEventListener("click",toggleUnfold);
  btnReset.addEventListener("click",()=>{ resetView(); });

  [mxp,mxn,myp,myn,mzp,mzn].forEach(el=>{
    el.addEventListener("change",()=>{ if(mode==="bagua") buildScene(); saveSettings(); });
  });
  [showHexNetEl,showStructureEl,hideYellowEl,showLabels64El,auto4dEl]
    .forEach(el=>el.addEventListener("change",()=>{ if(mode==="hex64") updateHUD(); saveSettings(); }));

  for (const btn of palaceBtns){
    btn.addEventListener("click",()=>{
      if (mode!=="bagua") mode="bagua";
      setPalace(btn.dataset.palace);
      buildScene();
      saveSettings();
    });
  }
  btnPalaceFree.addEventListener("click",()=>{
    setPalace(null);
    buildScene();
    saveSettings();
  });

  btnHudToggle.addEventListener("click",()=>{
    setHudCollapsed(!hud.classList.contains("collapsed"));
    saveSettings();
  });

  // ===== 初始化 =====
  resize();
  computePalaceBases();
  const loaded = loadSettings();

  // 如果没有保存过视角，给一个默认
  if (!currentPalace) currentPalace="乾";
  setPalace(currentPalace, false);     // 不重置旋转，用已保存的
  buildScene();
  if (!loaded){
    // 第一次打开，用默认视角
    resetView();
    if (window.innerWidth<=640) setHudCollapsed(true);
  } else {
    updateHUD();
  }

  requestAnimationFrame(render);
})();
</script>
</body>
</html>
