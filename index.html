<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>å…ˆå¤©å…«å¦ / 64å¦ï¼šå››ç»´è¶…ç«‹æ–¹ä½“ï¼ˆTesseractï¼‰</title>
  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#eef2f7; }
    canvas { display:block; width:100vw; height:100vh; touch-action:none; }

    #hud{
      position:fixed; left:12px; top:12px; z-index:10;
      background:rgba(0,0,0,.56); color:#fff;
      padding:10px 12px; border-radius:12px;
      font:14px/1.35 system-ui, -apple-system, "PingFang SC", "Microsoft YaHei", sans-serif;
      max-width:min(520px, calc(100vw - 24px));
    }
    #hud .title{ font-weight:800; margin-bottom:6px; }
    #hud .row{ display:flex; gap:8px; flex-wrap:wrap; align-items:center; margin-top:6px; }

    .chip{
      display:inline-flex; align-items:center; gap:6px;
      padding:2px 8px; border-radius:999px; background:rgba(255,255,255,.12);
    }
    .sw{ width:14px; height:14px; border-radius:4px; display:inline-block; border:1px solid rgba(255,255,255,.35); }

    button{
      appearance:none; border:1px solid rgba(255,255,255,.25);
      background:rgba(255,255,255,.10);
      color:#fff; border-radius:10px;
      padding:6px 10px; cursor:pointer;
      font:inherit;
    }
    button.active{ background:rgba(255,255,255,.22); border-color:rgba(255,255,255,.45); }
    button:active{ transform:translateY(1px); }

    .mini{ padding:4px 8px; border-radius:999px; }
    .sep{ width:1px; height:22px; background:rgba(255,255,255,.2); }

    #check, #detail { margin-top:8px; opacity:.95; }
    #detail b{ font-weight:800; }
    #panels { margin-top:8px; }
    #mirrorPanel, #hexPanel{ display:none; margin-top:8px; padding-top:8px; border-top:1px solid rgba(255,255,255,.18); }

    label{ display:inline-flex; align-items:center; gap:6px; }
    input[type="checkbox"]{ width:16px; height:16px; }
    input[type="range"]{ width:min(260px, 62vw); }
    .hint{ opacity:.85; font-size:12px; margin-top:6px; }

    .mono{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
  </style>
</head>
<body>
<canvas id="c"></canvas>

<div id="hud">
  <div class="title">bit ç«‹æ–¹ä½“ï¼š8å¦ / 64å¦ï¼ˆå››ç»´è¶…ç«‹æ–¹ä½“æŠ•å½±ï¼‰</div>

  <div class="row">
    <span class="chip"><span class="sw" style="background:#cfd6df;"></span>æµ…è‰² = é˜³çˆ»(0)</span>
    <span class="chip"><span class="sw" style="background:#1f2329;"></span>æ·±è‰² = é˜´çˆ»(1)</span>
    <span class="chip"><span class="sw" style="background:#ffd24a;"></span>é»„ç‚¹ = ç°å®(ä¸‹å¦)</span>
    <span class="chip"><span class="sw" style="background:#5ad6ff;"></span>è“ç‚¹ = çœŸæˆ‘(ä¸Šå¦)</span>
  </div>

  <div class="row">
    <button id="btnMode8" class="active">8å¦</button>
    <button id="btnMode64">64å¦</button>
    <span class="sep"></span>
    <button id="btnOrtho" class="active">æ­£äº¤</button>
    <button id="btnPersp">é€è§†</button>
    <button id="btnSnap" class="mini">å¯¹è§’è§†å›¾</button>
    <button id="btnReset" class="mini">é‡ç½®</button>
  </div>

  <div class="hint">äº¤äº’ï¼šæ‹–æ‹½æ—‹è½¬ï½œæ»šè½®/åŒæŒ‡ç¼©æ”¾ï½œç‚¹é¡¶ç‚¹æŸ¥çœ‹è¯¥ç‚¹â€œå åŠ æ€â†’64å¦â€</div>

  <div id="panels">
    <div id="mirrorPanel">
      <div style="font-weight:800; margin-bottom:6px;">é•œåƒç«‹æ–¹ä½“ï¼ˆæŒ‰é¢ç”Ÿæˆï¼‰</div>
      <div class="row">
        <label><input id="mxp" type="checkbox">+X</label>
        <label><input id="mxn" type="checkbox">-X</label>
        <label><input id="myp" type="checkbox">+Y</label>
        <label><input id="myn" type="checkbox">-Y</label>
        <label><input id="mzp" type="checkbox">+Z</label>
        <label><input id="mzn" type="checkbox">-Z</label>
      </div>
      <div class="hint">8å¦æ¨¡å¼ä¸‹ï¼šå‹¾é€‰åä»¥è¯¥é¢å››é¡¶ç‚¹ä¸ºâ€œå…±äº«é¢â€ï¼Œç”Ÿæˆé•œåƒ bit ç«‹æ–¹ä½“ã€‚</div>
    </div>

    <div id="hexPanel">
      <div style="font-weight:800; margin-bottom:6px;">64å¦ = å››ç»´è¶…ç«‹æ–¹ä½“(Tesseract)æŠ•å½± + å åŠ æ€</div>
      <div class="row">
        <label><input id="auto4d" type="checkbox" checked>è‡ªåŠ¨å››ç»´æ—‹è½¬</label>
        <label><input id="showTrue" type="checkbox">æ˜¾ç¤ºçœŸæˆ‘å½“å‰å¦</label>
      </div>
      <div class="row">
        <label style="gap:10px;">æ—¶é—´(å½±å“çœŸæˆ‘)ï¼š<input id="tTime" type="range" min="0" max="1" step="0.001" value="0"></label>
        <span class="mono" id="tTimeTxt">0.000</span>
      </div>
      <div class="row">
        <label style="gap:10px;">å åŠ åº¦(çœŸæˆ‘â†’ç°å®)ï¼š<input id="tSuper" type="range" min="0" max="1" step="0.001" value="0"></label>
        <span class="mono" id="tSuperTxt">0.000</span>
      </div>
      <div class="hint">
        å¤–å±‚é»„ç‚¹(ç°å®/ä¸‹å¦)ä¸å†…å±‚è“ç‚¹(çœŸæˆ‘/ä¸Šå¦)æ„æˆ tesseract çš„â€œä¸¤å±‚ç«‹æ–¹ä½“â€ã€‚<br>
        è“ç‚¹ä¸Šå¦ï¼šé»˜è®¤ä»â€œå…¨å(111 xor ä¸‹å¦)â€å‡ºå‘ï¼Œå¹¶éš <b>æ—¶é—´+å››ç»´æ—‹è½¬</b> åœ¨ 8 å¦é—´æµåŠ¨ï¼›å› æ­¤æ¯ä¸ªä¸‹å¦ç‚¹æœ‰ 8 ç§ä¸Šå¦å¯èƒ½æ€§ â‡’ å…¨å±€ 64 å¦ã€‚
      </div>
    </div>
  </div>

  <div id="check"></div>
  <div id="detail"></div>
</div>

<script>
(() => {
  // ====== å›ºå®šæ˜ å°„ï¼ˆå…ˆå¤©åºï¼šä¹¾å…‘ç¦»éœ‡å·½åè‰®å¤ = 000..111ï¼‰=====
  // é¡¶ç‚¹å¦bitsçº¦å®šï¼šbits = (åˆçˆ»,äºŒçˆ»,ä¸‰çˆ») = (Xå‘è¾¹, Yå‘è¾¹, Zå‘è¾¹)
  // ä½¿ç”¨å¯è§£è§„åˆ™ï¼ˆå±€éƒ¨bitåæ ‡ä¸‹ï¼‰ï¼š
  //   Xå‘è¾¹å€¼ = yBit
  //   Yå‘è¾¹å€¼ = zBit
  //   Zå‘è¾¹å€¼ = xBit
  // æ‰€ä»¥ é¡¶ç‚¹å¦bits = (y,z,x)  â‡’ bits = `${y}${z}${x}`
  const bitsToName = {
    "000":"ä¹¾","001":"å…‘","010":"ç¦»","011":"éœ‡",
    "100":"å·½","101":"å","110":"è‰®","111":"å¤"
  };

  const STEP = 2;     // 3D cube: bit 0â†’1 çš„ä¸–ç•Œåæ ‡å¢é‡
  const W_DIST = 4.0; // 4Dâ†’3D æŠ•å½±è·ç¦»ï¼ˆ>2å³å¯ï¼‰

  // ====== DOM ======
  const canvas = document.getElementById("c");
  const ctx = canvas.getContext("2d");

  const hudCheck  = document.getElementById("check");
  const hudDetail = document.getElementById("detail");

  const btnMode8  = document.getElementById("btnMode8");
  const btnMode64 = document.getElementById("btnMode64");
  const btnOrtho  = document.getElementById("btnOrtho");
  const btnPersp  = document.getElementById("btnPersp");
  const btnSnap   = document.getElementById("btnSnap");
  const btnReset  = document.getElementById("btnReset");

  const mirrorPanel = document.getElementById("mirrorPanel");
  const hexPanel    = document.getElementById("hexPanel");
  const mxp = document.getElementById("mxp");
  const mxn = document.getElementById("mxn");
  const myp = document.getElementById("myp");
  const myn = document.getElementById("myn");
  const mzp = document.getElementById("mzp");
  const mzn = document.getElementById("mzn");

  const auto4dEl  = document.getElementById("auto4d");
  const showTrueEl= document.getElementById("showTrue");
  const tTimeEl   = document.getElementById("tTime");
  const tSuperEl  = document.getElementById("tSuper");
  const tTimeTxt  = document.getElementById("tTimeTxt");
  const tSuperTxt = document.getElementById("tSuperTxt");

  // ====== é¢œè‰² ======
  const COLOR_YANG = "#cfd6df";  // æµ…è‰²ï¼ˆé˜³çˆ»0ï¼‰
  const COLOR_YIN  = "#1f2329";  // æ·±è‰²ï¼ˆé˜´çˆ»1ï¼‰
  const COLOR_NODE = "#0b0f14";
  const COLOR_LABEL = "#0b0f14";
  const COLOR_HI = "#ffb020";
  const COLOR_LINK = "rgba(40,50,60,.35)";
  const COLOR_REAL = "#ffd24a";  // é»„ï¼šç°å®
  const COLOR_TRUE = "#5ad6ff";  // è“ï¼šçœŸæˆ‘

  // ====== è§†å›¾çŠ¶æ€ ======
  let W=0, H=0, DPR=1;
  let mode = "bagua";      // "bagua" | "hex64"
  let projMode = "ortho";  // "ortho" | "persp"
  let rotX = -0.6;
  let rotY = 0.8;
  let zoom = 1.1;

  // ====== åœºæ™¯æ•°æ® ======
  let cubes = [];
  let vertices = [];
  let edges = [];
  let vByKey = new Map();
  let sceneMaxAbs = 1;

  // é€‰æ‹©
  let selSingle = null; // 8å¦é€‰ä¸­
  let selT = null;      // 64(tesseract)é€‰ä¸­

  // ====== tesseract: é…å¯¹ä¸â€œçœŸæˆ‘å½“å‰æ€â€ ======
  let tPair = new Map();        // key -> pairedKey
  let tTrueState = new Map();   // trueKey -> { upperBits, upperName, upperIdx }
  let tTime = 0;
  let tSuper = 0;
  let auto4dOn = true;
  let showTrueOn = false;

  // 4Dæ—‹è½¬è§’ï¼ˆ6ä¸ªæ—‹è½¬å¹³é¢é‡Œåªç”¨3ä¸ªå°±è¶³å¤Ÿå½¢æˆâ€œåƒwikié‚£æ ·â€çš„æ‰­åŠ¨ï¼‰
  let aXW = 0, aYW = 0, aYZ = 0;
  let lastTs = null;

  function syncTControls(){
    if (!tTimeEl) return;
    tTime = parseFloat(tTimeEl.value || "0");
    tSuper = parseFloat(tSuperEl.value || "0");
    auto4dOn = !!auto4dEl?.checked;
    showTrueOn = !!showTrueEl?.checked;
    if (tTimeTxt) tTimeTxt.textContent = tTime.toFixed(3);
    if (tSuperTxt) tSuperTxt.textContent = tSuper.toFixed(3);
  }
  [auto4dEl, showTrueEl, tTimeEl, tSuperEl].forEach(el => {
    if (!el) return;
    el.addEventListener("input", syncTControls);
    el.addEventListener("change", syncTControls);
  });

  // ====== resize ======
  function resize(){
    DPR = Math.max(1, Math.min(3, window.devicePixelRatio || 1));
    W = window.innerWidth; H = window.innerHeight;
    canvas.width  = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    canvas.style.width = W + "px";
    canvas.style.height = H + "px";
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener("resize", resize);

  // ====== å·¥å…·å‡½æ•°ï¼ˆ8å¦/é•œåƒç”¨ï¼‰ ======
  function keyOf(cubeId, x,y,z){ return `${cubeId}|${x},${y},${z}`; }

  function makeCubeInstance({id, label, offset={x:0,y:0,z:0}, axisBase={x:-1,y:-1,z:-1}, axisMirror={x:false,y:false,z:false}, showLabels=true, pickable=true}) {
    return {
      id, label, showLabels, pickable,
      ax: {
        x: { base: axisBase.x + offset.x, mirror: !!axisMirror.x },
        y: { base: axisBase.y + offset.y, mirror: !!axisMirror.y },
        z: { base: axisBase.z + offset.z, mirror: !!axisMirror.z },
      }
    };
  }

  function worldPos(cube, xBit,yBit,zBit){
    const wx = cube.ax.x.base + STEP * (cube.ax.x.mirror ? (1-xBit) : xBit);
    const wy = cube.ax.y.base + STEP * (cube.ax.y.mirror ? (1-yBit) : yBit);
    const wz = cube.ax.z.base + STEP * (cube.ax.z.mirror ? (1-zBit) : zBit);
    return {x:wx,y:wy,z:wz};
  }

  // ====== bits utils ======
  function trigramIndex(bits){ return (parseInt(bits,2) & 7) + 1; }
  function invertBits3(bits){ return bits.split("").map(ch => ch==="0"?"1":"0").join(""); }
  function bitsFromIdx(idx){
    return (idx & 7).toString(2).padStart(3,"0");
  }

  // ====== buildScene ======
  function buildScene(){
    selSingle = null;
    selT = null;

    cubes = [];
    vertices = [];
    edges = [];
    tPair.clear();
    tTrueState.clear();

    if (mode === "bagua"){
      mirrorPanel.style.display = "block";
      hexPanel.style.display = "none";

      const base = makeCubeInstance({ id:"B", label:"æœ¬å¦", showLabels:true, pickable:true });
      cubes.push(base);

      // 8å¦é•œåƒï¼ˆæŒ‰é¢ï¼‰
      const wantMirrors = [
        {on: mxp.checked, id:"Mx+", axis:"x", base:  1, mirror:true},
        {on: mxn.checked, id:"Mx-", axis:"x", base: -3, mirror:true},
        {on: myp.checked, id:"My+", axis:"y", base:  1, mirror:true},
        {on: myn.checked, id:"My-", axis:"y", base: -3, mirror:true},
        {on: mzp.checked, id:"Mz+", axis:"z", base:  1, mirror:true},
        {on: mzn.checked, id:"Mz-", axis:"z", base: -3, mirror:true},
      ];

      for (const m of wantMirrors){
        if (!m.on) continue;
        const axisBase = {x:-1,y:-1,z:-1};
        const axisMirror = {x:false,y:false,z:false};
        axisBase[m.axis] = m.base;
        axisMirror[m.axis] = true;
        cubes.push(makeCubeInstance({
          id: m.id, label:`é•œåƒ${m.id}`,
          axisBase, axisMirror,
          showLabels:false, pickable:false
        }));
      }

      // ç”Ÿæˆé¡¶ç‚¹&è¾¹ï¼ˆæ¯ä¸ª cubeï¼‰
      for (const cube of cubes){
        for (let x=0;x<=1;x++){
          for (let y=0;y<=1;y++){
            for (let z=0;z<=1;z++){
              const bits = `${y}${z}${x}`;
              const key = keyOf(cube.id, x,y,z);
              vertices.push({
                key,
                mode:"bagua",
                pickable: cube.pickable,
                showLabel: cube.showLabels,
                cubeId: cube.id,
                local:{x,y,z},
                bits,
                name: bitsToName[bits],
                world: worldPos(cube, x,y,z),
              });
            }
          }
        }

        // edges (12)
        for (let y=0;y<=1;y++) for (let z=0;z<=1;z++){
          edges.push({ type:"edge", cubeId:cube.id, axis:"X", val:y,
            a:keyOf(cube.id,0,y,z), b:keyOf(cube.id,1,y,z) });
        }
        for (let x=0;x<=1;x++) for (let z=0;z<=1;z++){
          edges.push({ type:"edge", cubeId:cube.id, axis:"Y", val:z,
            a:keyOf(cube.id,x,0,z), b:keyOf(cube.id,x,1,z) });
        }
        for (let x=0;x<=1;x++) for (let y=0;y<=1;y++){
          edges.push({ type:"edge", cubeId:cube.id, axis:"Z", val:x,
            a:keyOf(cube.id,x,y,0), b:keyOf(cube.id,x,y,1) });
        }
      }

      vByKey = new Map(vertices.map(v => [v.key, v]));
      // scene bounds
      sceneMaxAbs = 1;
      for (const v of vertices){
        sceneMaxAbs = Math.max(sceneMaxAbs, Math.abs(v.world.x), Math.abs(v.world.y), Math.abs(v.world.z));
      }

    } else {
      // ====== 64å¦ï¼štesseractï¼ˆå¤–å±‚ç°å®=é»„ï¼Œå†…å±‚çœŸæˆ‘=è“ï¼‰=====
      mirrorPanel.style.display = "none";
      hexPanel.style.display = "block";
      syncTControls();

      // å®šä¹‰ä¸¤å±‚ç«‹æ–¹ä½“ï¼šç°å®(å¤–å±‚) w=+1ï¼›çœŸæˆ‘(å†…å±‚) w=-1
      const roles = [
        { role:"reality", w:+1 },
        { role:"true",    w:-1 },
      ];

      for (const R of roles){
        for (let x=0;x<=1;x++){
          for (let y=0;y<=1;y++){
            for (let z=0;z<=1;z++){
              const bits = `${y}${z}${x}`;          // ä¸‹å¦bitsï¼ˆä¸8å¦åŒï¼‰
              const key = `T|${R.role}|${x},${y},${z}`;
              vertices.push({
                key,
                mode:"hex64",
                role: R.role,
                pickable:true,
                showLabel:true,
                local:{x,y,z},
                bits,
                name: bitsToName[bits],            // ç°å®ä¸‹å¦å
                invBits: invertBits3(bits),        // â€œå…¨åâ€å‚è€ƒ
                invName: bitsToName[invertBits3(bits)],
                base4: {                           // 4Dåæ ‡ï¼šx,y,zâˆˆ{-1,+1}, wâˆˆ{-1,+1}
                  x: x?+1:-1,
                  y: y?+1:-1,
                  z: z?+1:-1,
                  w: R.w
                }
              });
            }
          }
        }
      }

      vByKey = new Map(vertices.map(v => [v.key, v]));
      // é…å¯¹ï¼šåŒ(x,y,z) çš„ reality <-> true
      for (let x=0;x<=1;x++){
        for (let y=0;y<=1;y++){
          for (let z=0;z<=1;z++){
            const kr = `T|reality|${x},${y},${z}`;
            const kt = `T|true|${x},${y},${z}`;
            tPair.set(kr, kt);
            tPair.set(kt, kr);
          }
        }
      }

      // ç°å®/çœŸæˆ‘å„è‡ªçš„ 12 æ¡â€œçˆ»è¾¹â€ï¼ˆä»æ»¡è¶³å„è‡ª 6é˜³6é˜´ï¼‰
      function addCubeEdges(role){
        for (let y=0;y<=1;y++) for (let z=0;z<=1;z++){
          const a = `T|${role}|0,${y},${z}`;
          const b = `T|${role}|1,${y},${z}`;
          edges.push({ type:"edge", role, axis:"X", val:y, a, b });
        }
        for (let x=0;x<=1;x++) for (let z=0;z<=1;z++){
          const a = `T|${role}|${x},0,${z}`;
          const b = `T|${role}|${x},1,${z}`;
          edges.push({ type:"edge", role, axis:"Y", val:z, a, b });
        }
        for (let x=0;x<=1;x++) for (let y=0;y<=1;y++){
          const a = `T|${role}|${x},${y},0`;
          const b = `T|${role}|${x},${y},1`;
          edges.push({ type:"edge", role, axis:"Z", val:x, a, b });
        }
      }
      addCubeEdges("reality");
      addCubeEdges("true");

      // â€œwè¿æ¥è¾¹â€ï¼šæŠŠä¸¤å±‚ç«‹æ–¹ä½“å¯¹åº”é¡¶ç‚¹è¿èµ·æ¥ï¼ˆtesseract çš„ç¬¬4ç»´è¾¹ï¼‰
      for (let x=0;x<=1;x++){
        for (let y=0;y<=1;y++){
          for (let z=0;z<=1;z++){
            const a = `T|reality|${x},${y},${z}`;
            const b = `T|true|${x},${y},${z}`;
            edges.push({ type:"wlink", a, b });
          }
        }
      }

      // tesseract ç”»é¢èŒƒå›´ï¼ˆä¸ä¸¥æ ¼æ±‚æå€¼ï¼Œç»™ä¸ªç¨³å®šå€¼é¿å…ç¼©æ”¾æŠ–åŠ¨ï¼‰
      sceneMaxAbs = 3.2;
    }

    updateCheckText();
    updateDetailText(); // åˆå§‹
  }

  // ====== HUD ======
  function updateCheckText(){
    if (mode === "bagua"){
      let msg = [];
      const cubeIds = new Set(edges.filter(e=>e.type==="edge").map(e=>e.cubeId));
      for (const cid of cubeIds){
        let yang=0, yin=0;
        for (const e of edges){
          if (e.type!=="edge" || e.cubeId!==cid) continue;
          (e.val===0) ? yang++ : yin++;
        }
        msg.push(`${cid}:é˜³${yang} é˜´${yin} ${(yang===6&&yin===6)?"OK":"FAIL"}`);
      }
      hudCheck.innerHTML = `æ¨¡å¼ï¼š<b>8å¦</b> ï½œ æŠ•å½±ï¼š<b>${projMode==="ortho"?"æ­£äº¤":"é€è§†"}</b><br>` +
        `æ ¡éªŒï¼š${msg.join(" ï½œ ")}`;
    } else {
      // 64(tesseract)
      function count(role, val){
        let c=0;
        for (const e of edges){
          if (e.type==="edge" && e.role===role && e.val===val) c++;
        }
        return c;
      }
      const ry0=count("reality",0), ry1=count("reality",1);
      const ty0=count("true",0),    ty1=count("true",1);
      hudCheck.innerHTML =
        `æ¨¡å¼ï¼š<b>64å¦(tesseract)</b> ï½œ æŠ•å½±ï¼š<b>${projMode==="ortho"?"æ­£äº¤":"é€è§†"}</b><br>` +
        `ç°å®è¾¹ï¼šé˜³${ry0} é˜´${ry1} ï½œ çœŸæˆ‘è¾¹ï¼šé˜³${ty0} é˜´${ty1} ï½œ wè¿æ¥ï¼š${edges.filter(e=>e.type==="wlink").length}<br>` +
        `æ—¶é—´=${tTime.toFixed(3)} ï½œ å åŠ åº¦=${tSuper.toFixed(3)} ï½œ è‡ªåŠ¨4D=${auto4dOn?"ON":"OFF"}`;
    }
  }

  function updateDetailText(){
    if (mode === "bagua"){
      if (!selSingle){ hudDetail.innerHTML = ""; return; }
      const v = vByKey.get(selSingle);
      if (!v){ hudDetail.innerHTML=""; return; }
      hudDetail.innerHTML =
        `é€‰ä¸­ï¼š<b>${v.name}</b> bits=<b class="mono">${v.bits}</b>ï¼ˆå…ˆå¤©åºå·=${trigramIndex(v.bits)}ï¼‰<br>` +
        `local(x,y,z)=(${v.local.x},${v.local.y},${v.local.z}) ï½œ cube=${v.cubeId}`;
      return;
    }

    // tesseract detail
    if (!selT){ hudDetail.innerHTML = ""; return; }
    const v = vByKey.get(selT);
    if (!v){ hudDetail.innerHTML=""; return; }

    const pairKey = tPair.get(v.key);
    const pv = pairKey ? vByKey.get(pairKey) : null;

    const lowerV = (v.role==="reality") ? v : pv;   // ç°å®ä½œä¸ºä¸‹å¦
    const trueV  = (v.role==="true") ? v : pv;      // çœŸæˆ‘ä½œä¸ºä¸Šå¦

    if (!lowerV || !trueV){
      hudDetail.innerHTML = `é€‰ä¸­ï¼š<b>${v.role==="reality"?"ç°å®":"çœŸæˆ‘"}</b> é¡¶ç‚¹ bits=<b class="mono">${v.bits}</b>`;
      return;
    }

    const lowerBits = lowerV.bits;
    const lowerName = lowerV.name;
    const lowerIdx0 = parseInt(lowerBits,2) & 7;

    const state = tTrueState.get(trueV.key);
    const curUpperBits = state ? state.upperBits : trueV.invBits;
    const curUpperName = state ? state.upperName : trueV.invName;

    const hexBitsNow = `${curUpperBits}${lowerBits}`;
    const hexNumNow  = (parseInt(hexBitsNow,2) & 63) + 1;

    // è¯¥ç‚¹çš„ 8 ç§ä¸Šå¦å¯èƒ½æ€§ï¼ˆå½¢æˆ 8 ä¸ªå…­çˆ»ï¼›å…¨å±€ 8ç‚¹Ã—8=64ï¼‰
    let list = "";
    for (let i=0;i<8;i++){
      const ub = bitsFromIdx(i);
      const hn = bitsToName[ub];
      const hb = `${ub}${lowerBits}`;
      const num = (parseInt(hb,2) & 63) + 1;
      const isCur = (ub === curUpperBits);
      list += `${isCur?"ğŸ‘‰ ":""}ä¸Š${hn}(${ub}) + ä¸‹${lowerName}(${lowerBits}) = <span class="mono">${hb}</span> #${num}<br>`;
    }

    hudDetail.innerHTML =
      `é€‰ä¸­ï¼š<b>${v.role==="reality"?"ç°å®(ä¸‹å¦ç‚¹)":"çœŸæˆ‘(ä¸Šå¦ç‚¹)"}</b><br>` +
      `ä¸‹å¦ï¼š<b>${lowerName}</b> bits=<b class="mono">${lowerBits}</b>ï¼ˆåºå·=${lowerIdx0+1}ï¼‰<br>` +
      `ä¸Šå¦(å½“å‰)ï¼š<b>${curUpperName}</b> bits=<b class="mono">${curUpperBits}</b> â†’ å…­çˆ»=<b class="mono">${hexBitsNow}</b> #<b>${hexNumNow}</b><br>` +
      `<div style="margin-top:6px; font-weight:800;">è¯¥ç‚¹çš„ 8 ç§ä¸Šå¦å¯èƒ½æ€§ï¼ˆå åŠ æ€ï¼‰ï¼š</div>` +
      `<div style="margin-top:4px;">${list}</div>`;
  }

  // ====== 3D è§†è§’æ—‹è½¬ & æŠ•å½±ï¼ˆæ²¿ç”¨ä½ åŸæ¥çš„ï¼‰ ======
  function rotate3D(p){
    let x = p.x * zoom, y = p.y * zoom, z = p.z * zoom;

    const cy = Math.cos(rotY), sy = Math.sin(rotY);
    const x1 = x*cy + z*sy;
    const z1 = -x*sy + z*cy;

    const cx = Math.cos(rotX), sx = Math.sin(rotX);
    const y2 = y*cx - z1*sx;
    const z2 = y*sx + z1*cx;

    return {x:x1, y:y2, z:z2};
  }

  function getOrthoScale(){
    return 0.42 * Math.min(W,H) / Math.max(1e-6, sceneMaxAbs);
  }

  function project(world3){
    const pr = rotate3D(world3);

    if (projMode === "ortho"){
      const s = getOrthoScale();
      return { x: pr.x*s + W/2, y: -pr.y*s + H/2, z: pr.z, k: s };
    } else {
      const cameraDist = sceneMaxAbs * 4.2 + 2.0;
      const fov = Math.min(W,H) * 1.25;
      const z = pr.z + cameraDist;
      const k = fov / z;
      return { x: pr.x*k + W/2, y: -pr.y*k + H/2, z, k };
    }
  }

  // ====== 4D rotation helpers ======
  function rotPlane(v, i, j, ang){
    const c = Math.cos(ang), s = Math.sin(ang);
    const a = v[i], b = v[j];
    v[i] = a*c - b*s;
    v[j] = a*s + b*c;
  }

  function rotate4D(base4){
    // vec = [x,y,z,w]
    const v = [base4.x, base4.y, base4.z, base4.w];

    // åªç”¨ä¸‰ä¸ªå¹³é¢å°±è¶³ä»¥äº§ç”Ÿâ€œwiki tesseractâ€é‚£ç§æ‰­åŠ¨æ•ˆæœ
    rotPlane(v, 0, 3, aXW); // XW
    rotPlane(v, 1, 3, aYW); // YW
    rotPlane(v, 1, 2, aYZ); // YZ
    return v;
  }

  function project4Dto3D(v4){
    // 4Dâ†’3D é€è§†ï¼ˆæ²¿wï¼‰
    const w = v4[3];
    const f = W_DIST / (W_DIST - w);
    return { x: v4[0]*f, y: v4[1]*f, z: v4[2]*f, wRot: w };
  }

  function computeTesseractFrame(){
    // è¿”å›ï¼špos3ByKey, wRotByKeyï¼Œå¹¶æ›´æ–° tTrueState
    const pos3ByKey = new Map();
    const wRotByKey = new Map();

    // å…ˆç®—åŸå§‹4Dæ—‹è½¬+æŠ•å½±ï¼ˆä¸å åŠ ï¼‰
    for (const v of vertices){
      const v4 = rotate4D(v.base4);
      const p3 = project4Dto3D(v4);
      pos3ByKey.set(v.key, {x:p3.x, y:p3.y, z:p3.z});
      wRotByKey.set(v.key, p3.wRot);
    }

    // å åŠ ï¼šçœŸæˆ‘é¡¶ç‚¹å‘ç°å®é¡¶ç‚¹æ’å€¼ï¼ˆè®©ä½ çœ‹åˆ°â€œé¡¶ç‚¹äº’ç›¸å åŠ â€ï¼‰
    if (tSuper > 0){
      for (const v of vertices){
        if (v.role !== "true") continue;
        const pk = tPair.get(v.key);
        const pT = pos3ByKey.get(v.key);
        const pR = pk ? pos3ByKey.get(pk) : null;
        if (!pT || !pR) continue;
        pos3ByKey.set(v.key, {
          x: pT.x*(1-tSuper) + pR.x*tSuper,
          y: pT.y*(1-tSuper) + pR.y*tSuper,
          z: pT.z*(1-tSuper) + pR.z*tSuper,
        });
      }
    }

    // çœŸæˆ‘â€œå½“å‰ä¸Šå¦â€ï¼š
    // è§„åˆ™ï¼šä¸Šå¦idx = (å…¨åidx + timeStep + rotStep) mod 8
    // å…¶ä¸­ï¼šå…¨åidx = 7 - ä¸‹å¦idxï¼›timeStep=floor(time*8)ï¼›rotStepç”±è¯¥ç‚¹wRotå†³å®š
    tTrueState.clear();
    const timeStep = (Math.floor(tTime * 8) & 7);

    for (const v of vertices){
      if (v.role !== "true") continue;

      const pk = tPair.get(v.key);
      const lower = pk ? vByKey.get(pk) : null;
      const lowerBits = lower ? lower.bits : v.bits;
      const lowerIdx = (parseInt(lowerBits,2) & 7);
      const invIdx = (7 - lowerIdx) & 7;

      const wRot = wRotByKey.get(v.key) ?? 0;
      // wRot å¤§è‡´åœ¨ [-2,2]ï¼Œå½’ä¸€åŒ–åˆ°[0,1]å†å–0..7
      const rotNorm = Math.max(0, Math.min(1, (wRot + 2) / 4));
      const rotStep = (Math.floor(rotNorm * 8) & 7);

      const upperIdx = (invIdx + timeStep + rotStep) & 7;
      const upperBits = bitsFromIdx(upperIdx);
      tTrueState.set(v.key, { upperIdx, upperBits, upperName: bitsToName[upperBits] });
    }

    return pos3ByKey;
  }

  // ====== ç‚¹å‡»å‘½ä¸­ ======
  let lastProjCache = null;
  function hitTest(px,py, projCache){
    let best=null, bestD2=Infinity;
    for (const v of vertices){
      if (!v.pickable) continue;
      const p = projCache.get(v.key);
      if (!p) continue;
      const r = Math.max(9, 12 * (p.k/150));
      const dx = px - p.x, dy = py - p.y;
      const d2 = dx*dx + dy*dy;
      if (d2 < r*r && d2 < bestD2){ bestD2 = d2; best = v.key; }
    }
    return best;
  }

  // ====== äº¤äº’ï¼šæ‹–æ‹½æ—‹è½¬/ç¼©æ”¾ ======
  const pointers = new Map();
  let pointerDown = null;
  let pinchStart = null;

  canvas.addEventListener("pointerdown", (e) => {
    canvas.setPointerCapture(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});
    pointerDown = {x:e.clientX, y:e.clientY, t:performance.now()};
    if (pointers.size === 2){
      const pts = [...pointers.values()];
      const dx = pts[0].x - pts[1].x;
      const dy = pts[0].y - pts[1].y;
      pinchStart = {dist: Math.hypot(dx,dy), zoom};
    }
  });

  canvas.addEventListener("pointermove", (e) => {
    if (!pointers.has(e.pointerId)) return;
    const prev = pointers.get(e.pointerId);
    pointers.set(e.pointerId, {x:e.clientX, y:e.clientY});

    if (pointers.size === 1){
      const dx = e.clientX - prev.x;
      const dy = e.clientY - prev.y;
      rotY += dx * 0.008;
      rotX += dy * 0.008;
      rotX = Math.max(-1.45, Math.min(1.45, rotX));
    } else if (pointers.size === 2 && pinchStart){
      const pts = [...pointers.values()];
      const dx = pts[0].x - pts[1].x;
      const dy = pts[0].y - pts[1].y;
      const dist = Math.hypot(dx,dy);
      const factor = dist / pinchStart.dist;
      zoom = Math.max(0.55, Math.min(3.2, pinchStart.zoom * factor));
    }
  });

  canvas.addEventListener("pointerup", (e) => {
    pointers.delete(e.pointerId);
    if (pointers.size < 2) pinchStart = null;

    if (!pointerDown) return;
    const dx = e.clientX - pointerDown.x;
    const dy = e.clientY - pointerDown.y;
    const dt = performance.now() - pointerDown.t;
    pointerDown = null;

    if (dt < 350 && (dx*dx+dy*dy) < 16*16){
      const pc = lastProjCache;
      if (!pc) return;
      const hit = hitTest(e.clientX, e.clientY, pc);
      if (!hit) return;

      if (mode === "bagua"){
        selSingle = (selSingle === hit) ? null : hit;
      } else {
        selT = (selT === hit) ? null : hit;
      }
      updateDetailText();
    }
  });

  canvas.addEventListener("wheel", (e) => {
    e.preventDefault();
    const delta = Math.sign(e.deltaY);
    const factor = (delta > 0) ? 0.92 : 1.08;
    zoom = Math.max(0.55, Math.min(3.2, zoom * factor));
  }, {passive:false});

  // ====== æ¸²æŸ“ ======
  function render(ts){
    ctx.setTransform(DPR,0,0,DPR,0,0);
    ctx.clearRect(0,0,W,H);

    if (mode === "hex64"){
      syncTControls();
      if (lastTs == null) lastTs = ts;
      const dt = ts - lastTs;
      lastTs = ts;

      if (auto4dOn){
        // è½»é‡ä¸”ç¨³å®šçš„ 4D è‡ªåŠ¨æ—‹è½¬
        aXW += dt * 0.00055;
        aYW += dt * 0.00035;
        aYZ += dt * 0.00045;
      }
    }

    // è®¡ç®—æœ¬å¸§ 3D ç‚¹ä½
    let pos3ByKey = new Map();
    if (mode === "bagua"){
      for (const v of vertices) pos3ByKey.set(v.key, v.world);
    } else {
      pos3ByKey = computeTesseractFrame();
      // çœŸæˆ‘çŠ¶æ€ä¼šå˜ï¼šå¦‚æœæœ‰é€‰ä¸­ç‚¹ï¼Œå®æ—¶åˆ·æ–° detail
      if (selT) updateDetailText();
      updateCheckText();
    }

    // build projection cache
    const projCache = new Map();
    for (const v of vertices){
      const p3 = pos3ByKey.get(v.key);
      if (!p3) continue;
      projCache.set(v.key, project(p3));
    }
    lastProjCache = projCache;

    // edges sort (far -> near)
    const edgesSorted = edges.map(e => {
      const pa = projCache.get(e.a);
      const pb = projCache.get(e.b);
      const z = ((pa?.z ?? 1e9) + (pb?.z ?? 1e9)) * 0.5;
      return {e, pa, pb, z};
    }).sort((a,b) => b.z - a.z);

    // selection helpers
    const selKey = (mode==="bagua") ? selSingle : selT;
    const selPair = (mode==="hex64" && selKey) ? tPair.get(selKey) : null;

    // draw edges
    for (const item of edgesSorted){
      const {e, pa, pb} = item;
      if (!pa || !pb) continue;

      const isSel = !!selKey && (e.a===selKey || e.b===selKey);
      const isPair= !!selPair && (e.a===selPair || e.b===selPair);
      const isHi  = isSel || isPair;

      ctx.beginPath();
      ctx.moveTo(pa.x, pa.y);
      ctx.lineTo(pb.x, pb.y);

      if (e.type === "wlink"){
        ctx.lineWidth = isHi ? 5.2 : 2.2;
        ctx.strokeStyle = isHi ? COLOR_HI : COLOR_LINK;
        ctx.setLineDash([6,6]);
        ctx.stroke();
        ctx.setLineDash([]);
        continue;
      }

      // edge within cube
      ctx.lineWidth = isHi ? 6.2 : 3.2;
      const baseColor = (e.val===0 ? COLOR_YANG : COLOR_YIN);
      if (mode==="hex64" && e.role==="true"){
        // çœŸæˆ‘å±‚ç¨å¾®é€æ˜ä¸€ç‚¹
        ctx.strokeStyle = isHi ? COLOR_HI : baseColor;
        if (!isHi) ctx.globalAlpha = 0.70;
        ctx.stroke();
        ctx.globalAlpha = 1;
      } else {
        ctx.strokeStyle = isHi ? COLOR_HI : baseColor;
        ctx.stroke();
      }
    }

    // vertices sort (far -> near)
    const vertsSorted = vertices.map(v => ({v, p: projCache.get(v.key)}))
      .filter(x => !!x.p)
      .sort((a,b) => b.p.z - a.p.z);

    for (const {v, p} of vertsSorted){
      const r = 7 + (p.k/110);
      const isSelected = (mode==="bagua" && selSingle===v.key) ||
                         (mode==="hex64" && (selT===v.key));
      const isPaired = (mode==="hex64" && selPair===v.key);

      // node fill
      let fill = COLOR_NODE;
      if (mode==="hex64"){
        fill = (v.role==="reality") ? COLOR_REAL : COLOR_TRUE;
      }
      if (isSelected || isPaired) fill = COLOR_HI;

      ctx.beginPath();
      ctx.arc(p.x, p.y, (isSelected||isPaired) ? r*1.25 : r, 0, Math.PI*2);
      ctx.fillStyle = fill;
      ctx.globalAlpha = 0.92;
      ctx.fill();
      ctx.globalAlpha = 1;

      // label
      if (mode==="bagua"){
        if (v.showLabel){
          ctx.fillStyle = COLOR_LABEL;
          ctx.font = "14px system-ui, -apple-system, 'PingFang SC', 'Microsoft YaHei', sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "bottom";
          ctx.fillText(`${v.name} ${v.bits}`, p.x, p.y - ((isSelected)? r*1.6 : r*1.25));
        }
      } else {
        // tesseract labelsï¼šç°å®å§‹ç»ˆæ˜¾ç¤ºï¼›çœŸæˆ‘å¯é€‰æ˜¾ç¤ºï¼ˆæˆ–è¢«é€‰ä¸­/é…å¯¹æ—¶æ˜¾ç¤ºï¼‰
        const showLabel = (v.role==="reality") || showTrueOn || isSelected || isPaired;
        if (showLabel){
          let text = "";
          if (v.role === "reality"){
            text = `${v.name} ${v.bits}`; // ä¸‹å¦å›ºå®š
          } else {
            const st = tTrueState.get(v.key);
            const ub = st ? st.upperBits : v.invBits;
            const un = st ? st.upperName : v.invName;
            text = showTrueOn ? `${un} ${ub}` : "âˆ‘"; // ä¸å¼€â€œæ˜¾ç¤ºçœŸæˆ‘â€æ—¶åªç»™ä¸ªå åŠ ç¬¦å·
          }

          ctx.fillStyle = COLOR_LABEL;
          ctx.font = "13px system-ui, -apple-system, 'PingFang SC', 'Microsoft YaHei', sans-serif";
          ctx.textAlign = "center";
          ctx.textBaseline = "bottom";
          ctx.fillText(text, p.x, p.y - ((isSelected||isPaired)? r*1.6 : r*1.25));
        }
      }
    }

    requestAnimationFrame(render);
  }

  // ====== UI ======
  function setMode(newMode){
    mode = newMode;
    btnMode8.classList.toggle("active", mode==="bagua");
    btnMode64.classList.toggle("active", mode==="hex64");
    buildScene();
    resetView();
  }

  function setProj(newProj){
    projMode = newProj;
    btnOrtho.classList.toggle("active", projMode==="ortho");
    btnPersp.classList.toggle("active", projMode==="persp");
    updateCheckText();
  }

  function snapDiagonal(){
    rotY = -Math.PI/4;
    rotX = Math.atan(1/Math.sqrt(2));
  }

  function resetView(){
    rotX = -0.6;
    rotY = 0.8;
    zoom = (mode==="hex64") ? 1.0 : 1.1;
  }

  btnMode8.addEventListener("click", () => setMode("bagua"));
  btnMode64.addEventListener("click", () => setMode("hex64"));
  btnOrtho.addEventListener("click", () => setProj("ortho"));
  btnPersp.addEventListener("click", () => setProj("persp"));
  btnSnap.addEventListener("click", () => { setProj("ortho"); snapDiagonal(); });
  btnReset.addEventListener("click", () => resetView());

  // 8å¦é•œåƒé€‰é¡¹å˜æ›´åé‡å»º
  [mxp,mxn,myp,myn,mzp,mzn].forEach(el => el.addEventListener("change", () => buildScene()));

  // ====== init ======
  resize();
  buildScene();
  resetView();
  requestAnimationFrame(render);
})();
</script>
</body>
</html>
